<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Monarch</title>
    <link href="/2022/03/19/Monarch/"/>
    <url>/2022/03/19/Monarch/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="812aacba843fbeb260a1c4a6ab494f175c47b959944a82ae70642d9c9303e78c">d4e92a42f1929de57d9067fafb4a6cfcb6787bd53d97d5e07cde26a7fabfffd9cf85b43cfaa8ff2aebec59beaec15fe2dd5dbfce52f41dc7217305f48e827838c50fa35131251ee37761d8615dbbfd09e2990ed7184090cf59fa53ba5e4e9f32fa81d45cacd4af4ea63be1763d0dd43db700166dd49d83e445d237a7eb11a06c4ef1cee6812565a8b173d199d68fff0ada28bfc1cfe3a2fa66adcf34055baac5d6b36f358bd8289fba274ac9b10a6c33a8e2767ecca07b0322d12001b6ba231f0a551f120e1934cbefdfec77fbc148d59a392a287f3f1bbfe99d8c1c4a04ca0a1c5081ab0993230a73eb399d8aeb0d3c9442ee5d2228128e89141a49d57868ca5b2786b291b5cc1045fdcf033e93d099</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">FBI warning</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>monarch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>to me</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/16/ACDaily/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/16/ACDaily/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组和线段树</title>
    <link href="/2022/03/15/ACDaily/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/03/15/ACDaily/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组和线段树"><a href="#树状数组和线段树" class="headerlink" title="树状数组和线段树"></a>树状数组和线段树</h1><p>树状数组相比线段树更快，代码更短</p><h2 id="一-树状数组"><a href="#一-树状数组" class="headerlink" title="一.树状数组"></a>一.树状数组</h2><ul><li>树状数组的下标是从1开始的</li><li>基本功能<ul><li>在某个位置上加上一个数，即单点修改</li><li>求某个前缀和，即区间查询</li></ul></li></ul><div align="center">    <img src="/2022/03/15/ACDaily/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/Users\23950\AppData\Roaming\Typora\typora-user-images\image-20220312095824311.png" alt="image-20220312095824311" style="zoom:80%;"></div><ul><li>树状数组的每个元素<code>c[x]表示A[x]中区间[x-lowbit(x), x]里的数的和</code>，<code>lowbit(x)</code>表示x的二进制形式后0的个数，也可以表示为<code>x&amp;-x</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 求和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i), res += c[i]) <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 递归形式求和</span><br><br><span class="hljs-comment">// 对某数进行修改后需要进行的调整</span><br>A[x] += v;  <span class="hljs-comment">// 对x位置数进行加法改变</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i), c[x] += v)  <span class="hljs-comment">// 每次指标上升一层</span><br></code></pre></div></td></tr></table></figure><blockquote><p>解决问题需要的操作决定了数据结构的选取，比如如果要修改某个元素且需要修改某个子序列的和，那么就可以用树状数组。数据结构的难点也在这里</p></blockquote><h3 id="例：动态求连续区间和"><a href="#例：动态求连续区间和" class="headerlink" title="例：动态求连续区间和"></a>例：动态求连续区间和</h3><p>给定 n 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [a,b] 的连续和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m，分别表示数的个数和操作次数。</p><p>第二行包含 n 个整数，表示完整数列。</p><p>接下来 m 行，每行包含三个整数 k,a,b （k=0，表示求子数列[a,b]的和；k=1，表示第 a 个数加 b）。</p><p>数列从 1 开始计数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出若干行数字，表示 k=0 时，对应的子数列 [a,b] 的连续和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000,<br>1≤m≤100000，<br>1≤a≤b≤n,<br>数据保证在任何时候，数列中所有元素之和均在 int 范围内。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>10 5<br>1 2 3 4 5 6 7 8 9 10<br>1 1 5<br>0 1 3<br>0 4 8<br>1 7 5<br>0 4 8</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>11<br>30<br>35</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> tr[N], w[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;-x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">add</span>(i, w[i]);<br>    <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k, a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-built_in">query</span>(b) - <span class="hljs-built_in">query</span>(a<span class="hljs-number">-1</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="二-线段树"><a href="#二-线段树" class="headerlink" title="二.线段树"></a>二.线段树</h2><ul><li>存储: 一维数组，与堆的存储方式相同。</li></ul><div align="center">    <img src="/2022/03/15/ACDaily/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/dpayment\new\source\_posts\ACDaily\树状数组和线段树.assets\image-20220316000334508.png" alt="image-20220316000334508" style="zoom: 80%;"></div><ul><li><p>通常有两个操作：</p><ol><li><p>单点修改</p></li><li><p>区间查询</p></li></ol></li><li><p>基本函数：</p><ol><li><p>pushup 用子节点信息更新当前节点信息</p></li><li><p>build 在一段区间上初始化线段树</p></li><li><p>modify 修改</p></li><li><p>query 某区间的特定关系</p></li></ol></li></ul><h3 id="例：数列区间最大值"><a href="#例：数列区间最大值" class="headerlink" title="例：数列区间最大值"></a>例：数列区间最大值</h3><p>输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 N,M 表示数字的个数和要询问的次数；</p><p>接下来一行为 N 个数；</p><p>接下来 M 行，每行都有两个整数 X,Y。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共 M 行，每行输出一个数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤105,<br>1≤M≤106,<br>1≤X≤Y≤N,<br>数列中的数字均不超过231−1</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><p>10 2<br>3 2 4 5 6 8 1 2 9 7<br>1 4<br>3 8</p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><p>5<br>8</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>本题中modify操作没有体现，之后会用线段树实现一遍动态求连续区间和，开个坑。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> m, n;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> w[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> l, r;<br>    <span class="hljs-keyword">int</span> maxv;<br>&#125;tr[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) tr[u] = &#123;l, r, w[r]&#125;;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        tr[u] = &#123;l, r&#125;;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);<br>        tr[u].maxv = <span class="hljs-built_in">max</span>(tr[u &lt;&lt; <span class="hljs-number">1</span>].maxv, tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].maxv);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].maxv;<br>    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> maxm = INT_MIN;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) maxm = <span class="hljs-built_in">max</span>(maxm, <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r));<br>    <span class="hljs-keyword">if</span>(r &gt; mid) maxm = <span class="hljs-built_in">max</span>(maxm, <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r));<br>    <span class="hljs-keyword">return</span> maxm;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i]);<br>    <br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <br>    <span class="hljs-keyword">int</span> x, y;<br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, x, y));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WOOP</title>
    <link href="/2022/03/11/advice/WOOP%E7%90%86%E8%AE%BA/"/>
    <url>/2022/03/11/advice/WOOP%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我们从第一个字母开始。第一个字母是W。W就是wish的缩写，就是愿望的意思。请想象你最想通过努力实现的事情。如果你有好几个愿望，那就选一个对你而言最重要的。记住，一次只能想一个愿望。</p><p>想好了吗？好，现在我们来到第二个字母，O。O是outcome，结果。你实现愿望或解决心事之后，最好的结果是什么？在四周安全的情况下，你可以闭上眼睛想象,努力量化你的愿望，或者想象愿望实现的情景。想象一下这个结果。现在请你生动形象地想象和这件事相关的画面，不用顾虑。假如我的愿望是减肥成功，这件事的结果，我会想象，我穿上了一件喜欢的漂亮衣服，照相的时候，我也会很大方自信，而当我奔跑的时候，我感觉自己的双腿前所未有地轻盈，我总是喜欢跑跑跳跳。</p><p>好了，睁开眼睛，我们进入下一个步骤，也是最重要的一个步骤。第三个字母，还是O，obstacle，障碍。你实现梦想的障碍是什么？找到那个妨碍你达成愿望的最严重的内心的障碍。是什么想法和行为让你为难？是不是某种习惯或某个先入为主的想法？在思索障碍的时候，人们往往会在外部寻找，怪到客观条件上，甚至是别人身上。如果外部障碍真的严重到让梦想不可能实现，那么就换个愿望，把精力投入到自己能改变的部分上来。</p><p>这个障碍可能是很具体的，比如“玩了太久电脑”；也可能是很普遍的，如“觉得累”和“没时间”；也可以是某种行为、情绪、观念、冲动、恶习、猜测。刚开始时可能很难，因为人们都不愿真诚地剖析自己。但如果你能找到最关键的障碍，那么实现梦想的可能性就大大增加了。很多人都觉得，在完成这个步骤之后，他们会产生满足感，甚至觉得如释重负。</p><p>P：plan，计划。要克服或规避这个障碍的话，你能怎么做？想出最有效的想法和行动，将它牢记于心，然后想一想这个障碍下次将在何时何地出现。接着制订一个“如果……那么我就……”计划：“如果障碍X出现了，那么我就采取行动Y。”然后将这个计划重复一遍给自己听。“如果我回家觉得很累，那么我还是会穿上跑鞋跑一千米。”“如果我想吃冰淇淋，那么我就穿上跑鞋跑一千米。”“如果我想刷视频，那么我就马上开始看书。”这中间不必有逻辑链接，简单粗暴也没问题。</p><p>文章转自<a href="https://www.dedao.cn/audioBook/detail?id=lXR8oDpLOEvk0o3E90PG2zYg1AwB5N">反惰性</a></p>]]></content>
    
    
    <categories>
      
      <category>advice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>inspiration</tag>
      
      <tag>心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 8</title>
    <link href="/2022/03/10/ACDaily/ACDaily-8/"/>
    <url>/2022/03/10/ACDaily/ACDaily-8/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举、模拟问题续"><a href="#枚举、模拟问题续" class="headerlink" title="枚举、模拟问题续"></a>枚举、模拟问题续</h1><h2 id="1-移动距离"><a href="#1-移动距离" class="headerlink" title="1.移动距离"></a>1.移动距离</h2><p>X星球居民小区的楼房全是一样的，并且按矩阵样式排列。</p><p>其楼房的编号为  1,2,3…<br>当排满一行时，从下一行相邻的楼往反方向排号。</p><p>比如：当小区排号宽度为 6 时，开始情形如下：</p><p>1  2  3  4  5  6<br>12 11 10 9  8  7<br>13 14 15 …..<br>我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共一行，包含三个整数 w,m,n，w 为排号宽度，m,n 为待计算的楼号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 m,n 两楼间最短移动距离。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤w,m,n≤10000,</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>6 8 2</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>4</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>考虑枚举每个数，按照排列方式将单个数字转化为对应的二维坐标，进行计算即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> w, m, n;<br>    cin &gt;&gt; w &gt;&gt; m &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">int</span> mx, my, nx, ny;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> min = w*i+<span class="hljs-number">1</span>, max = w*(i+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(m &gt;= min &amp;&amp; m &lt;= max &amp;&amp; i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) mx = m-min, my = i;<br>        <span class="hljs-keyword">if</span>(m &gt;= min &amp;&amp; m &lt;= max &amp;&amp; i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>) mx = max-m, my = i;<br>        <span class="hljs-keyword">if</span>(n &gt;= min &amp;&amp; n &lt;= max &amp;&amp; i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) nx = n-min, ny = i;<br>        <span class="hljs-keyword">if</span>(n &gt;= min &amp;&amp; n &lt;= max &amp;&amp; i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>) nx = max-n, ny = i;<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">abs</span>(mx-nx)+<span class="hljs-built_in">abs</span>(my-ny) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-日期问题"><a href="#2-日期问题" class="headerlink" title="2.日期问题"></a>2.日期问题</h2><p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。</p><p>小明知道这些日期都在1960年1月1日至2059年12月31日。</p><p>令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。</p><p>更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</p><p>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。</p><p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个日期，格式是”AA/BB/CC”。</p><p>即每个’/’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。</p><p>多个日期按从早到晚排列。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0≤A,B,C≤9</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><p>02/03/04</p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><p>2002-03-04<br>2004-02-03<br>2004-03-02</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>架构：</p><ol><li>选择规格化输入，可以避免很多麻烦</li><li>已知日期范围，枚举日期种数，简化代码逻辑</li><li>按题意对日期进行自由组合</li><li>判别日期的合理性</li><li>规格化输出，注意补前导零</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> days[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check_valid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (month == <span class="hljs-number">0</span> || month &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (day == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (month != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (day &gt; days[month]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> leap = ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">if</span> (day &gt; days[month] + leap) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d/%d/%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> date = <span class="hljs-number">19600101</span>; date &lt;= <span class="hljs-number">20591231</span>; date ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> year = date / <span class="hljs-number">10000</span>, month = date % <span class="hljs-number">10000</span> / <span class="hljs-number">100</span>, day = date % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_valid</span>(year, month, day))<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((year % <span class="hljs-number">100</span> == a &amp;&amp; month == b &amp;&amp; day == c) ||  <span class="hljs-comment">// 年/月/日</span><br>                (month == a &amp;&amp; day == b &amp;&amp; year % <span class="hljs-number">100</span> == c) ||  <span class="hljs-comment">// 月/日/年</span><br>                (day == a &amp;&amp; month == b &amp;&amp; year % <span class="hljs-number">100</span> == c) )   <span class="hljs-comment">//月/日/年</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%02d-%02d\n&quot;</span>, year, month, day);  <span class="hljs-comment">//补前导0</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-航班时间"><a href="#3-航班时间" class="headerlink" title="3.航班时间"></a>3.航班时间</h2><p>小 h 前往美国参加了蓝桥杯国际赛。</p><p>小 h 的女朋友发现小 h 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。</p><p>小 h 对超音速飞行感到十分恐惧。</p><p>仔细观察后发现飞机的起降时间都是当地时间。</p><p>由于北京和美国东部有 12 小时时差，故飞机总共需要 14 小时的飞行时间。</p><p>不久后小 h 的女朋友去中东交换。</p><p>小 h 并不知道中东与北京的时差。</p><p>但是小 h 得到了女朋友来回航班的起降时间。</p><p>小 h 想知道女朋友的航班飞行时间是多少。</p><p>对于一个可能跨时区的航班，给定来回程的起降时间。</p><p>假设飞机来回飞行时间相同，求飞机的飞行时间。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个输入包含多组数据。</p><p>输入第一行为一个正整数 T，表示输入数据组数。</p><p>每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。</p><p>起降时间的格式如下:</p><p>h1:m1:s1 h2:m2:s2<br>h1:m1:s1 h3:m3:s3 (+1)<br>h1:m1:s1 h4:m4:s4 (+2)<br>第一种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间当日h2时m2分s2秒降落。</p><p>第二种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间次日h2时m2分s2秒降落。</p><p>第三种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间第三日h2时m2分s2秒降落。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一组数据输出一行一个时间hh:mm:ss，表示飞行时间为hh小时mm分ss秒。</p><p>注意，当时间为一位数时，要补齐前导零，如三小时四分五秒应写为03:04:05。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>保证输入时间合法（0≤h≤23,0≤m,s≤59），飞行时间不超过24小时。</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><p>3<br>17:48:19 21:57:24<br>11:05:18 15:14:23<br>17:21:07 00:31:46 (+1)<br>23:02:41 16:13:20 (+1)<br>10:19:19 20:41:24<br>22:19:04 16:41:09 (+1)</p><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><p>04:09:05<br>12:10:39<br>14:22:05</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>架构：</p><ol><li>解决时差与计算飞行用时的问题。考虑地球自转与飞机飞行，我们可以类比小学奥数的小船过河问题。也就是说，我们已知去程与返程的抵达时间与出发时间的差值s1和s2，由于<code>飞行时间=目的地时间-出发地时间+时差（可正可负）</code>而来回的时差一定是互为相反数的，因此我们可以令<code>(s1+s2)/2</code>得到我们需要的飞行时间。</li><li>本题的难点其实不在上述逻辑，而在于数据的读入与规格化。我们发现读入的数据是有一定格式的，并且有的数据带+1，有的却不带，因此我们需要为不带+的数据进行人为添加（+0）以使得数据规格化。然后要学会用sscanf来对规格化后的数据进行提取，因为时分秒的时间格式是难以进行加减运算的，所以我们需要设置一个基准，即距离当天0点所过去的秒数。利用我们提取的数据，就可以做到非常好的转换。</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_second</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h*<span class="hljs-number">3600</span>+<span class="hljs-number">60</span>*m+s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string line;<br>    <span class="hljs-built_in">getline</span>(cin, line);<br>    <br>    <span class="hljs-keyword">int</span> h1, m1, s1, h2, m2, s2, d;<br>    <span class="hljs-keyword">if</span>(line.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;)&#x27;</span>) line += <span class="hljs-string">&quot; (+0)&quot;</span>;<br>    <span class="hljs-built_in">sscanf</span>(line.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2, &amp;d);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_second</span>(h2, m2, s2) - <span class="hljs-built_in">get_second</span>(h1, m1, s1) + <span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    string line;<br>    <span class="hljs-built_in">getline</span>(cin, line);<br>    <br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> time = (<span class="hljs-built_in">get_time</span>() + <span class="hljs-built_in">get_time</span>())/<span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">int</span> hour, minute, second;<br>        hour = time/<span class="hljs-number">3600</span>;<br>        minute = time%<span class="hljs-number">3600</span>/<span class="hljs-number">60</span>;<br>        second = time%<span class="hljs-number">60</span>;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d\n&quot;</span>, hour, minute, second);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-外卖店优先级"><a href="#4-外卖店优先级" class="headerlink" title="4.外卖店优先级"></a>4.外卖店优先级</h2><p>“饱了么”外卖系统中维护着 N 家外卖店，编号 1∼N。</p><p>每家外卖店都有一个优先级，初始时 (0 时刻) 优先级都为 0。</p><p>每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。</p><p>如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果优先级小于等于 3，则会被清除出优先缓存。</p><p>给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优先缓存中。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含 3 个整数 N,M,T。</p><p>以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到一个订单。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数代表答案。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M,T≤105,<br>1≤ts≤T,<br>1≤id≤N</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><p>2 6 6<br>1 1<br>5 2<br>3 1<br>6 2<br>2 1<br>6 2</p><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><p>1</p><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>6 时刻时，1 号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6，加入优先缓存。</p><p>所以是有 1 家店 (2 号) 在优先缓存中。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>架构：</p><ol><li>暴力做法，按照时间推移，对每家店的优先级进行变化和分析，但这样的话时间复杂度为100亿，超时在所难免，所以我们需要对算法进行优化。</li><li>考虑到订单量相比店家量理论是更少的，因此大多数店家在大多数时刻都接收不到新订单，也就是说，大多数店家的优先级减小时刻是紧密相连的，也就是以减小块的形式出现，因此我们可以记下在每个时间点每家店最后接收订单的时刻。由此我们就可以非常简单地处理优先级减小问题，将考虑的对象聚焦在获得订单的那些店上，问题就被简化了。</li><li>利用成熟的数据结构进行数据的存储</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> score[N], last[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br>PII order[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, T;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;order[i].x, &amp;order[i].y);<br>    <span class="hljs-built_in">sort</span>(order, order+m);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m;)<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = i;<br>        <span class="hljs-keyword">while</span>(j &lt; m &amp;&amp; order[i] == order[j]) j++;<br>        <span class="hljs-keyword">int</span> t = order[i].x, id = order[i].y, cnt = j-i;<br>        i = j;<br>        <br>        score[id] -= t - last[id] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(score[id] &lt; <span class="hljs-number">0</span>) score[id] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(score[id] &lt;= <span class="hljs-number">3</span>) st[id] = <span class="hljs-literal">false</span>;<br>        <br>        score[id] += cnt*<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(score[id] &gt; <span class="hljs-number">5</span>) st[id] = <span class="hljs-literal">true</span>;<br>        last[id] = t;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(last[i] &lt; T)<br>        &#123;<br>            score[i] -= T-last[i];<br>            <span class="hljs-keyword">if</span>(score[i] &lt;= <span class="hljs-number">3</span>) st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        res += st[i];<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>规格化输入与输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 7</title>
    <link href="/2022/03/09/ACDaily/ACDaily-7/"/>
    <url>/2022/03/09/ACDaily/ACDaily-7/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举、模拟问题"><a href="#枚举、模拟问题" class="headerlink" title="枚举、模拟问题"></a>枚举、模拟问题</h1><p>这类问题通常没有一个非常契合的算法作为计算模板，但通常数据量是有过精心设计的。</p><p>我们可以通过以下问题来看一看。</p><h2 id="1-连续区间段"><a href="#1-连续区间段" class="headerlink" title="1.连续区间段"></a>1.连续区间段</h2><blockquote><p>没有思路时，从暴力做法入手</p><p>整体复杂度由每一步的复杂度进行组合后确定</p><p>一般可以通过一半的小数字样例</p><p>遍历复杂度为O(n)，排序算法复杂度为nlogn</p><p>当多重循环内包含大于等于10句话，就属于长代码了。</p><p>形成暴力做法的思考闭环后，有想法可以对算法进行优化</p></blockquote><p>逆向思考，什么样的区间满足连号区间，可以发现连号区间等价于区间里最大数-最小数=区间端点差值。有了这样的思路我们就可以进行如下的设计：</p><p>先枚举区间左端点，再枚举区间右端点，根据以上思考对方案进行判别。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 1∼N 的某个排列中有多少个连号区间呢？</p><p>这里所说的连号区间的定义是：</p><p>如果区间 [L,R] 里的所有元素（即此排列的第 L 个到第 R 个元素）递增排序后能得到一个长度为 R−L+1 的“连续”数列，则称这个区间连号区间。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个正整数 N，表示排列的规模。</p><p>第二行是 N 个不同的数字 Pi，表示这 N 个数字的某一排列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示不同连号区间的数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10000,<br>1 ≤ Pi ≤ N</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h4><p>4<br>3 2 4 1</p><h5 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释:"></a>样例1解释:</h5><p>第一个用例中，有 7 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]</p><h4 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h4><p>7</p><h4 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h4><p>5<br>3 4 2 5 1</p><h5 id="样例2解释"><a href="#样例2解释" class="headerlink" title="样例2解释:"></a>样例2解释:</h5><p>第二个用例中，有 9 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]</p><h4 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h4><p>9</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>, INF = <span class="hljs-number">1000000000</span>;<br><span class="hljs-keyword">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> maxv = -INF, minv = INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt;= n; j++)<br>        &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, a[j]);<br>            minv = <span class="hljs-built_in">min</span>(minv, a[j]);<br>            <span class="hljs-keyword">if</span>(maxv-minv == j-i) res++;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-递增三元组"><a href="#2-递增三元组" class="headerlink" title="2.递增三元组"></a>2.递增三元组</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定三个整数数组</p><p>A=[A1,A2,…AN],<br>B=[B1,B2,…BN],<br>C=[C1,C2,…CN],</p><p>请你统计有多少个三元组 (i,j,k) 满足：</p><p>1 ≤ i,j,k ≤ N<br>Ai &lt; Bj &lt; Ck</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N。</p><p>第二行包含 N 个整数 A1,A2,…AN。</p><p>第三行包含 N 个整数 B1,B2,…BN。</p><p>第四行包含 N 个整数 C1,C2,…CN。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数表示答案。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10^5,<br>0 ≤ Ai,Bi,Ci ≤ 10^5</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><p>3<br>1 1 1<br>2 2 2<br>3 3 3</p><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><p>27</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><ol><li>首先，我们可以选择一个处理的起点，我们要求满足条件的组合数，考虑到A、C都由B限制，并且观察到数据量为10亿，无法做多重循环，所以我们能且仅能遍历一个数组B。</li><li>由于A、B、C中数的比较为相对关系，而数的范围是从0开始的，为了避免特判，我们可以使每个数+1而不改变相对关系</li><li>要时刻考虑计算的每个环节，在本题中方案数可能超过int范围，所以我们将计数器变量定义为LL类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">```<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> a[N], b[N], c[N];<br><span class="hljs-keyword">int</span> sa[N], sc[N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i], a[i]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; b[i], b[i]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; c[i], c[i]++;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) sa[a[i]]++, sc[c[i]]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) sa[i] += sa[i<span class="hljs-number">-1</span>], sc[i] += sc[i<span class="hljs-number">-1</span>];<br>    <br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        res += (LL)(sa[b[i]<span class="hljs-number">-1</span>])*(sc[N]-sc[b[i]]);<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>```<br></code></pre></div></td></tr></table></figure><h2 id="3-特别数的和"><a href="#3-特别数的和" class="headerlink" title="3.特别数的和"></a>3.特别数的和</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。</p><p>请问，在 1 到 n 中，所有这样的数的和是多少？</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示满足条件的数的和。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤10000</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><p>输入样例：<br>40<br>输出样例：<br>574</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>本题的关键在于数位的切分，懂得如何利用循环将一个数每一位切下来就可以简单地处理掉这个问题</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">```<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> last, val = i;<br>        <span class="hljs-keyword">while</span>(val)<br>        &#123;<br>            last = val % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(last == <span class="hljs-number">2</span> || last == <span class="hljs-number">0</span> || last == <span class="hljs-number">1</span> || last == <span class="hljs-number">9</span>)<br>            &#123;<br>                res += i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            val /= <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>```<br></code></pre></div></td></tr></table></figure><h2 id="4-错误票据"><a href="#4-错误票据" class="headerlink" title="4.错误票据"></a>4.错误票据</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>某涉密单位下发了某种票据，并要在年终全部收回。</p><p>每张票据有唯一的ID号。</p><p>全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p><p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p><p>你的任务是通过编程，找出断号的ID和重号的ID。</p><p>假设断号不可能发生在最大和最小号。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示后面共有 N 行数据。</p><p>接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>要求程序输出1行，含两个整数 m,n，用空格分隔。</p><p>其中，m表示断号ID， n 表示重号ID。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤100</p><h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><p>blablabla</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>本题地难点在于数据的读取，剩下的，就是一个简单的模拟了，本题的数据量也不是很大。</p><ol><li>在使用getline读取信息时，如果在之前有使用cin读入数据，就要对getline做一次初始化处理，因为cin后会默认将一个空格放在流中，也就是说我们首先要将这个无意义的操作排除。</li><li>geline每次可以读取一行信息，只有按下回车才会结束一次读取，它有两个参数，一个是外部输入流cin，一个是空字符串对象line。在使用getline后本次读取的全部信息都会被存储在对象中。</li><li>我们可以使用stringstream类中的ssin读取方法，它能够赋予字符串流的特性。即<code>stringstream ssin(line)</code>，进行这样的定义之后，我们就可以使用<code>line &gt;&gt; a[i]</code>以空格作为区分将line中的数据一个个输出。</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">```<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k, cnt = <span class="hljs-number">0</span>;<br>    string line;<br>    cin &gt;&gt; k;<br>    <br>    <span class="hljs-built_in">getline</span>(cin, line);<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        <span class="hljs-built_in">getline</span>(cin, line);<br>        <span class="hljs-function">stringstream <span class="hljs-title">ssin</span><span class="hljs-params">(line)</span></span>;<br>        <span class="hljs-keyword">while</span>(ssin &gt;&gt; a[cnt]) cnt++;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(a, a+cnt);<br>    <br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i] == a[i<span class="hljs-number">-1</span>]) n = a[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i] &gt;= a[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>) m = a[i] - <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>```<br></code></pre></div></td></tr></table></figure><h2 id="5-回文日期"><a href="#5-回文日期" class="headerlink" title="5.回文日期"></a>5.回文日期</h2><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</p><p>牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。</p><p>显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。</p><p>牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。</p><p>现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。</p><p>一个 8 位数字是回文的，当且仅当对于所有的 i(1≤i≤8) 从左向右数的第i个数字和第 9−i 个数字（即从右向左数的第 i 个数字）是相同的。</p><p>例如：</p><p>•对于2016年11月19日，用 8 位数字 20161119 表示，它不是回文的。</p><p>•对于2010年1月2日，用 8 位数字 20100102 表示，它是回文的。</p><p>•对于2010年10月2日，用 8 位数字 20101002 表示，它不是回文的。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包括两行，每行包括一个8位数字。</p><p>第一行表示牛牛指定的起始日期date1，第二行表示牛牛指定的终止日期date2。保证date1和date2都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。</p><p>保证date1一定不晚于date2。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含一个整数，表示在date1和date2之间，有多少个日期是回文的。</p><h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><p>输入样例</p><p>20110101<br>20111231<br>输出样例</p><p>1</p><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>本题的第一个关键在于策略的选取，首先年份信息理论上分布于1000与10000之间，构成回文数又只需要前4位，因此我们考虑枚举前4位的所有可能，通过数位切分构成回文数。之后判别该回文数是否位于目标范围内。</p><p>之后就需要考虑日期的合理性，即分别对年、月、日进行讨论。月数不能超过1<del>12，天数不能超过1</del>31，这是最基本的要求。</p><p>最后，考虑日期的现实性，2月的天数取决于该年是否为闰年，我们需要对其做更深入的分类讨论。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">```<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> mon[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> date)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> year = date/<span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">int</span> month = date%<span class="hljs-number">10000</span>/<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">int</span> day = date%<span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">if</span>(month &lt; <span class="hljs-number">1</span> || month &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(month == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> leap = year%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year%<span class="hljs-number">100</span> != <span class="hljs-number">0</span> || year %<span class="hljs-number">400</span> == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(day &gt; mon[<span class="hljs-number">1</span>]+leap) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(day == <span class="hljs-number">0</span> || month != <span class="hljs-number">2</span> &amp;&amp; day &gt; mon[month<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> date1, date2;<br>    cin &gt;&gt; date1 &gt;&gt; date2;<br>    <br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1000</span>; i &lt;= <span class="hljs-number">9999</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> date = i, x = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>        &#123;<br>            date = date*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(date &gt;= date1 &amp;&amp; date &lt;= date2 &amp;&amp; <span class="hljs-built_in">check</span>(date)) cnt++;<br>    &#125;<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>```<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 6</title>
    <link href="/2022/03/06/ACDaily/ACDaily-6/"/>
    <url>/2022/03/06/ACDaily/ACDaily-6/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题练习与LeetCode初体验"><a href="#背包问题练习与LeetCode初体验" class="headerlink" title="背包问题练习与LeetCode初体验"></a>背包问题练习与LeetCode初体验</h1><p>这两天做题效率低了一些，不过背包是一块难啃的骨头，要集中一些。</p><h2 id="波动数列"><a href="#波动数列" class="headerlink" title="波动数列"></a>波动数列</h2><p>观察这个数列：</p><p>1 3 0 2 -1 1 -2 …</p><p>这个数列中后一项总是比前一项增加2或者减少3，且每一项都为整数。</p><p>栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种呢？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含四个整数 n,s,a,b，含义如前面所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示满足条件的方案数。</p><p>由于这个数很大，请输出方案数除以 100000007 的余数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000,<br>−109≤s≤109,<br>1≤a,b≤106</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>4 10 2 3</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>2</p><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>两个满足条件的数列分别是2 4 1 3和7 4 1 -2。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>, MOD = <span class="hljs-number">100000007</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_mod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (a%b + b) % b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, s, a, b;<br>    cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;<br>    <br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n<span class="hljs-number">-1</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            f[i][j] = (f[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">get_mod</span>(j-a*(n-i), n)]+f[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">get_mod</span>(j + b*(n-i), n)]) % MOD;<br>        &#125;<br>        <br>    cout &lt;&lt; f[n<span class="hljs-number">-1</span>][<span class="hljs-built_in">get_mod</span>(s, n)] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>按照我们在<a href="https://www.waitingfor.cn/2022/03/05/ACDaily/ACDaily-5/">ACDaily 5</a>提到的标准流程，先做好状态表示，再做好状态计算。</p><p>根据题意我们要求的是所有方案数，因此状态数组内存的应该是方案数。那么我们要给出的，是哪一类方案数呢。根据题意，我们可以设置一个起点数x，之后的每个数由于只比前一个数大a或少b，我们把它们记作di，表示相对于第i-1项的变化量。</p><p>在做了以上数学转换后，我们就可以得到一个等值的表达式。再来看看目的：n个数的序列之和应该是n的倍数，因此，我们可以将问题转化为：序列和s与di组合mod n达到同余要求的所有方案。</p><p>所以我们可以用<code>f[i][j]</code>表示前i个d(d1~dn-1)的所有组合同余j的方案数。</p><p>接着，我们根据化整为零的思想按照序列最后一项的区别对集合进行划分。观察到最后一项仅有<code>(n-i)*a</code>和<code>-(n-1)*b</code>两种可能，于是我们将这两种情况的方案数相加就可以得到当下情况的方案数。</p><p>再经过状态的合并来获得目标方案。</p><ul><li>几点要明确的</li></ul><ol><li>C++中负数模正数是可以得到负余数的，例如<code>a &lt; 0, b &gt; 0</code> <code>a%b</code>就属于<code>-(b-1) ~ (b-1)</code>，因此在本题中设计了函数将负余数转化为正余数。</li><li>一切从实际出发，考虑各特征的合理范围</li><li>特别注意初始化起点的值</li><li>由于MOD为9位数，所以对于多数相加取模问题，我们需要一步一步地先做加法再取模，也就是加一个数，取一次模，再加一个数，再取一次模，直到把所有数加完。</li></ol><h2 id="LeetCode初体验"><a href="#LeetCode初体验" class="headerlink" title="LeetCode初体验"></a>LeetCode初体验</h2><p>第一次参加LeetCode周赛，有许多不适应的地方，不过参加过了就有了一些了解与体会。</p><ol><li>LeetCode系统会默认添加所有C++头文件，这也是很多人喜欢用C++打比赛的原因，因为STL的数据结构集成性非常好。</li><li>在代码区，系统会为你提供一个Solution类，并且给出解答该题的函数设计框架，算是一种提示吧。如果需要全局变量，我们就需要设计静态成员，然后初始化；一般变量则可以直接在函数内定义。其实，规范一些，我们的所有变量都应该在数据成员区进行定义。</li><li>要多打打这些有时限的算法比赛，激活自己的状态，同时也能意识到自己在哪些地方有不足，是一种很好的反馈。</li><li>这次只AC了一道题，与大佬们还有很大差距，冲冲冲。</li></ol><h2 id="Excel表中某个范围内的单元格"><a href="#Excel表中某个范围内的单元格" class="headerlink" title="Excel表中某个范围内的单元格"></a>Excel表中某个范围内的单元格</h2><p>概述：给定一个Excel表格区间<code>letter1 i:letter2 j</code>并且<code>&#39;A&#39;&lt;= letter1 &lt;= letter2 &lt;= &#39;Z&#39;, i &lt;= j</code>，要求输出这个范围的所有格子，假如给定的区间为<code>K1:L2</code>,那么我们就应该输出向量<code>[&quot;K1&quot;, &quot;K2&quot;, &quot;L1&quot;, &quot;L2&quot;]</code>，可以看到，在满足条件的区域遍历的顺序为由上而下，由左而右。</p><p>原题链接可以参考<a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">LeetCode.6016</a></p><h3 id="原始人做法"><a href="#原始人做法" class="headerlink" title="原始人做法"></a>原始人做法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">cellsInRange</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; list;<br>        <span class="hljs-keyword">char</span> a[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">char</span> b[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">char</span> letter[<span class="hljs-number">26</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>            letter[i] = i+<span class="hljs-number">65</span>;<br>        <br>        <span class="hljs-keyword">char</span> *str = (<span class="hljs-keyword">char</span>*)s.<span class="hljs-built_in">data</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *d = <span class="hljs-string">&quot;:&quot;</span>;<br>        <span class="hljs-keyword">char</span> *p;<br>        p = <span class="hljs-built_in">strtok</span>(str, d);<br>        a[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>];<br>        b[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>];<br>        p = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">nullptr</span>, d);<br>        a[<span class="hljs-number">1</span>] = p[<span class="hljs-number">0</span>];<br>        b[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">int</span> num1 = b[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">int</span> num2 = b[<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">int</span> letter1 = a[<span class="hljs-number">0</span>]<span class="hljs-number">-65</span>;<br>        <span class="hljs-keyword">int</span> letter2 = a[<span class="hljs-number">1</span>]<span class="hljs-number">-65</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = letter1; i &lt;= letter2; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = num1; j &lt;= num2; j++)<br>            &#123;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> num = j+<span class="hljs-number">48</span>;<br>                <span class="hljs-keyword">char</span> p[<span class="hljs-number">80</span>];<br>                p[<span class="hljs-number">0</span>] = letter[i];<br>                p[<span class="hljs-number">1</span>] = num;<br>                list.<span class="hljs-built_in">insert</span>(list.<span class="hljs-built_in">end</span>(), p);<br>            &#125;<br>        <br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="STL加持做法"><a href="#STL加持做法" class="headerlink" title="STL加持做法"></a>STL加持做法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">cellsInRange</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> a = s[<span class="hljs-number">0</span>], b = s[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">int</span> p = s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>, q = s[<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = a; c &lt;= b; ++c) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = p; d &lt;= q; ++d) &#123;<br>                string t&#123;c, (<span class="hljs-keyword">char</span>)(d + <span class="hljs-string">&#x27;0&#x27;</span>)&#125;;<br>                ans.<span class="hljs-built_in">push_back</span>(t);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>STL作用太大了，需要好好学学。</p><p>其实STL对于我们学习数据结构也是很有帮助的，以STL数据结构为参照，对应其中的功能来实现我们自己的类应该是一种更好的学法，毕竟我们学习数据结构不是为了在使用时造轮子而是更好地去驾驭已经比较完善的库中的它们，毕竟STL内的数据结构实现比我们要完善的多吧doge。</p>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>背包问题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>字符串拆分与拼接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 5</title>
    <link href="/2022/03/05/ACDaily/ACDaily-5/"/>
    <url>/2022/03/05/ACDaily/ACDaily-5/</url>
    
    <content type="html"><![CDATA[<h1 id="从集合角度分析DP问题"><a href="#从集合角度分析DP问题" class="headerlink" title="从集合角度分析DP问题"></a>从集合角度分析DP问题</h1><h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><ul><li><p>一般问法：最值（价值等属性）、达到某一目标的方向总数</p></li><li><p>背包问题的本质为组合问题，即在一定条件下从一部分物品中挑选物品；同时也类似于图论的最短路，可以说，DP是一种特殊的图论</p></li><li><p>暴力做法：方案数量为指数级</p></li><li><p>化零为整：挖掘不同方案间的共同关系，把有相同关系的元素放在一起</p></li><li><p>化整为零：把一个集合划分为多个子集，进行分析</p></li><li><p>解决问题的过程中一定抓住从实际含义出发</p></li></ul><p>具体的分析在下述例题中会有解释</p><p>题解的优化可以参考<a href="https://www.waitingfor.cn/2022/03/04/ACDaily/ACDaily-4/">ACDaily 4</a></p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><blockquote><p>本题题解具体优化可以参考<a href="https://www.waitingfor.cn/2022/03/04/ACDaily/ACDaily-4/">ACDaily 4</a>，此处借此例讲解动态规划基本的算法架构</p></blockquote><h3 id="算法架构：动态规划集合化"><a href="#算法架构：动态规划集合化" class="headerlink" title="算法架构：动态规划集合化"></a>算法架构：动态规划集合化</h3><ol><li><p>状态表示（一般为二维，不可能超时）<code>f[i][j]</code></p><ul><li>集合的思想，<code>f[i][j]</code>表示的并非是j体积背包下对前i个物品进行选择下的价值最大值，<strong>而是j体积下对前i个物品进行选择下的所有方案的最大价值</strong>（每个物品可选可不选）</li><li>属性：min、max、count，即数组中的元素表示最值或方案数</li></ul></li><li><p>状态计算(化零为整)</p><ol><li>集合的划分，划分依据：<strong>最后一个不同点</strong>。即在限制条件下（确定问题域），按<strong>选或不选第i个物品（i个物品中的最后物品）对方案进行划分</strong>为A（选i）和B（不选i)集合<ul><li>要求：不重不漏，每个子集中的元素具有相同共性（都选或没选第i个物品），各子集又能组合成全集</li></ul></li><li>对不选i的集合中（B）所有方案的最大价值进行计算，得到max1</li><li>按物品选择是否发生变化，对上述划分包含选择第i个物品的方案（即A方案集合）进行分区，物品i所在区域为不变区，前i-1个物品组成的区域为变化区</li><li>寻找变化区中总价值最大的物品选择方案，加上第i个物品的价值，得到最大价值max2</li><li>求<code>max(max1, max2)</code>,得到整体最大价值</li></ol><blockquote><p>关键在于选择划分方式，例如以下的摘花生与最大子序列长度</p></blockquote></li></ol><h2 id="1-摘花生"><a href="#1-摘花生" class="headerlink" title="1. 摘花生"></a>1. 摘花生</h2><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p><p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p><p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p><p>Hello Kitty只能向东或向南走，不能向西或向北走。</p><p>问Hello Kitty最多能够摘到多少颗花生。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个整数T，代表一共有多少组数据。</p><p>接下来是T组数据。</p><p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p><p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤T≤100,<br>1≤R,C≤100,<br>0≤M≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>2<br>2 2<br>1 1<br>3 4<br>2 3<br>2 3 4<br>1 6 5</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>8<br>16</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">55</span>, MOD = <span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">int</span> w[N][N];<br><span class="hljs-keyword">int</span> f[N][N][<span class="hljs-number">13</span>][<span class="hljs-number">14</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;    <br>            cin &gt;&gt; w[i][j];<br>            w[i][j]++;  <span class="hljs-comment">// 调整整体价值范围</span><br>        &#125;<br>            <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][w[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 起点已进行过初始化</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt;= k; u++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt;= <span class="hljs-number">13</span>; v++)<br>                &#123;<br>                    <span class="hljs-keyword">int</span> &amp;val = f[i][j][u][v];<br>                    val = (val + f[i<span class="hljs-number">-1</span>][j][u][v]) % MOD;<br>                    val = (val + f[i][j<span class="hljs-number">-1</span>][u][v]) % MOD;<br>                    <br>                    <span class="hljs-keyword">if</span>(u &gt; <span class="hljs-number">0</span> &amp;&amp; v == w[i][j])<br>                    &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; v; c++)<br>                        &#123;<br>                            val = (val + f[i<span class="hljs-number">-1</span>][j][u<span class="hljs-number">-1</span>][c]) % MOD;<br>                            val = (val + f[i][j<span class="hljs-number">-1</span>][u<span class="hljs-number">-1</span>][c]) % MOD;<br>                        &#125;<br>                        <br>                    &#125;<br>                &#125;<br>        &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt;= <span class="hljs-number">13</span>; c++) res = (res + f[n][m][k][c]) % MOD;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-最长上升子序列"><a href="#2-最长上升子序列" class="headerlink" title="2. 最长上升子序列"></a>2. 最长上升子序列</h2><p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000，<br>−109≤数列中的数≤109</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><p>7<br>3 1 2 1 8 5 6</p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><p>4</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> w[N], f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; w[i];<br><br>    <span class="hljs-keyword">int</span> mx = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 找出所计算的f[i]之中的最大值，边算边找</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        f[i] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 设f[i]默认为1，找不到前面数字小于自己的时候就为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (w[i] &lt; w[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 这种写法是f[j]已经更新过的正常写法</span><br>        &#125;<br>        mx = <span class="hljs-built_in">max</span>(mx, f[i]);<br>    &#125;<br><br>    cout &lt;&lt; mx &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-地宫寻宝"><a href="#3-地宫寻宝" class="headerlink" title="3. 地宫寻宝"></a>3. 地宫寻宝</h2><p>X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。</p><p>地宫的入口在左上角，出口在右下角。</p><p>小明被带到地宫的入口，国王要求他只能向右或向下行走。</p><p>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p><p>当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。</p><p>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行 3 个整数，n,m,k，含义见题目描述。</p><p>接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示正好取 k 个宝贝的行动方案数。</p><p>该数字可能很大，输出它对 1000000007 取模的结果。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤50,<br>1≤k≤12,<br>0≤Ci≤12</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><p>2 2 2<br>1 2<br>2 1</p><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><p>2</p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><p>2 3 2<br>1 2 3<br>2 1 5</p><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><p>14</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">55</span>, MOD = <span class="hljs-number">1000000007</span>;<br><span class="hljs-keyword">int</span> w[N][N];<br><span class="hljs-keyword">int</span> f[N][N][<span class="hljs-number">13</span>][<span class="hljs-number">14</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;    <br>            cin &gt;&gt; w[i][j];<br>            w[i][j]++;  <span class="hljs-comment">// 调整整体价值范围</span><br>        &#125;<br>            <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][w[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 起点已进行过初始化</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt;= k; u++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt;= <span class="hljs-number">13</span>; v++)<br>                &#123;<br>                    <span class="hljs-keyword">int</span> &amp;val = f[i][j][u][v];<br>                    val = (val + f[i<span class="hljs-number">-1</span>][j][u][v]) % MOD;<br>                    val = (val + f[i][j<span class="hljs-number">-1</span>][u][v]) % MOD;<br>                    <br>                    <span class="hljs-keyword">if</span>(u &gt; <span class="hljs-number">0</span> &amp;&amp; v == w[i][j])<br>                    &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; v; c++)<br>                        &#123;<br>                            val = (val + f[i<span class="hljs-number">-1</span>][j][u<span class="hljs-number">-1</span>][c]) % MOD;<br>                            val = (val + f[i][j<span class="hljs-number">-1</span>][u<span class="hljs-number">-1</span>][c]) % MOD;<br>                        &#125;<br>                        <br>                    &#125;<br>                &#125;<br>        &#125;<br>    <br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt;= <span class="hljs-number">13</span>; c++) res = (res + f[n][m][k][c]) % MOD;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 4</title>
    <link href="/2022/03/04/ACDaily/ACDaily-4/"/>
    <url>/2022/03/04/ACDaily/ACDaily-4/</url>
    
    <content type="html"><![CDATA[<h1 id="不简单DP"><a href="#不简单DP" class="headerlink" title="不简单DP"></a>不简单DP</h1><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a><strong>输入样例</strong></h4><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a><strong>输出样例：</strong></h4><p>8</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解:"></a><strong>题解</strong>:</h4><p>这道题若使用暴力做法，可以将题意转化为：给定n位二进制序列（即n个物品，若该位为1，则表示选择该物品，反之不选择），每一位对应一个价值和一个体积，枚举所有所有可能的组合，先判断能不能装进背包，若能装，则计算总价值，更新当前最大价值，反之，不更新最大价值，最后输出最大价值即可。通过分析，我们可以发现这种做法的复杂度为指数级别，超时不可避免，因此我们需要优化算法。</p><h5 id="1-用二维数组做动态决策"><a href="#1-用二维数组做动态决策" class="headerlink" title="1.用二维数组做动态决策"></a>1.用二维数组做动态决策</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> v[N], w[N], f[N][N];  <span class="hljs-comment">// f数组记录的是j体积下前i个物品的最大价值</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-comment">// 记录物品的个数和背包的容积</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];  <span class="hljs-comment">// 初始化物品体积和价值</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) f[i][j] = f[i<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 难点在于为什么判断j &lt; v[i]就可以，因为前i-1间物品是可选可不选的</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j], f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i]); <br>            &#125;<br>        &#125;<br>    <br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>本方法的关键在于**构造<code>j</code>体积背包下的i个物品的最大价值数组<code>f[N][N]</code>**。那么为什么要做这样的假设呢，因为我们最终要求的是背包容量为<code>j</code>的<code>i</code>个物品的最大价值，由递推的思想，<code>j</code>体积背包下前<code>i</code>个物品的最大价值可以由前<code>i-1</code>个物品的最大价值来推导，因此我们可以从最原始的状态出发，不断增加物品数量，在每个物品数量<code>i</code>下，背包的体积<code>j</code>从1开始增长到m，通过对这些情况进行依次判断与选择来确定<code>j</code>体积背包下前<code>i</code>个物品的最大价值。</p><h5 id="2-优化：用一维数组做动态决策"><a href="#2-优化：用一维数组做动态决策" class="headerlink" title="2.优化：用一维数组做动态决策"></a>2.优化：用一维数组做动态决策</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> v[N], w[N], f[N];  <span class="hljs-comment">// 本方法中的假设与一般方法相同，使用降维的方法，将一些冗余的数值剔除了（可以单步模拟之后的遍历来观察）</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-comment">// 记录物品的个数和背包的容积</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];  <span class="hljs-comment">// 初始化物品体积和价值</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= v[i]; j--)  <br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);  <span class="hljs-comment">// 这种写法相对于一般写法将一些无法更新的位置略过了</span><br>    &#125; <br>    <br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用该种优化后，可以省略掉j与v[i]的判断语句，优化循环的终止条件。但要注意j为逆序遍历，这样做的原因是防止当前最大价值计算时需要用到的之前最大价值被污染，这一点也可以通过简单的模拟来实现。</p><h5 id="3-输入优化"><a href="#3-输入优化" class="headerlink" title="3.输入优化"></a>3.输入优化</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> f[MAXN];  <span class="hljs-comment">// </span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;   <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;      <span class="hljs-comment">// 边输入边处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= v; j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于两个循环皆有边读入边处理的特性，因此我们可以将这两个循环进行一个合并，减小语句长度。</p><p>以上就是对该类问题初步理解而做出的阐述，后续再遇到此类问题时会对内容进行一个更清晰的重构。</p><p>对此问题更好的解释可以参考<a href="https://www.acwing.com/solution/content/1374/">状态转移方程的解释</a>。</p>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 3</title>
    <link href="/2022/03/03/ACDaily/ACDaily-3/"/>
    <url>/2022/03/03/ACDaily/ACDaily-3/</url>
    
    <content type="html"><![CDATA[<h1 id="数学与简单DP"><a href="#数学与简单DP" class="headerlink" title="数学与简单DP"></a>数学与简单DP</h1><h2 id="数学（根据例题讲解）"><a href="#数学（根据例题讲解）" class="headerlink" title="数学（根据例题讲解）"></a>数学（根据例题讲解）</h2><h3 id="买不到的数"><a href="#买不到的数" class="headerlink" title="买不到的数"></a>买不到的数</h3><p>小明开了一家糖果店。</p><p>他别出心裁：把水果糖包成4颗一包和7颗一包的两种。</p><p>糖果不能拆包卖。</p><p>小朋友来买糖的时候，他就用这两种包装来组合。</p><p>当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。</p><p>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。</p><p>大于17的任何数字都可以用4和7组合出来。</p><p>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h4><p>两个正整数 n,m，表示每种包装中糖的颗数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h4><p>一个正整数，表示最大不能买到的糖数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h4><p>2≤n,m≤1000，<br>保证数据一定有解。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a><strong>输入样例：</strong></h4><p>4 7</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a><strong>输出样例：</strong></h4><p>17</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, res = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    res = (m<span class="hljs-number">-1</span>)*(n<span class="hljs-number">-1</span>) - <span class="hljs-number">1</span>;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li><p>找最大公约数，如哦不是最大公约数的倍数则无解</p></li><li><p>打表找规律，裴蜀定理，获得公式，具体公式推导可以参考<a href="https://www.acwing.com/solution/content/3165/">AcWing525</a></p><ul><li><p>最后进行公式输出即可</p></li><li><p>递归能够确定终点，需要由终点进行反推，来判断深搜是否成立，中间进行的递归是为了确定深搜中不同的方向（与二叉树相似）</p></li><li><p>注意这仅仅是打表</p></li><li><p>最终还要根据数据表内的信息来寻找规律</p></li></ul></li></ol><h3 id="感冒的蚂蚁"><a href="#感冒的蚂蚁" class="headerlink" title="感冒的蚂蚁"></a>感冒的蚂蚁</h3><p>长 100 厘米的细长直杆子上有 n 只蚂蚁。</p><p>它们的头有的朝左，有的朝右。</p><p>每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。</p><p>当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。</p><p>这些蚂蚁中，有 1 只蚂蚁感冒了。</p><p>并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。</p><p>请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h4><p>第一行输入一个整数 n, 表示蚂蚁的总数。</p><p>接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。</p><p>正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。</p><p>其中，第一个数据代表的蚂蚁感冒了。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h4><p>输出1个整数，表示最后感冒蚂蚁的数目。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h4><p>1&lt;n&lt;50,<br>0&lt;|Xi|&lt;100</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a><strong>输入样例1：</strong></h4><p>3<br>5 -2 8</p><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a><strong>输出样例1：</strong></h4><p>3</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a><strong>题解</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">60</span>;<br><span class="hljs-keyword">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i]) &lt; <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">0</span>]) &amp;&amp; a[i] &gt; <span class="hljs-number">0</span>) left++;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i]) &gt; <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">0</span>]) &amp;&amp; a[i] &lt; <span class="hljs-number">0</span>) right++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span> || a[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> &amp;&amp; left == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; left+right+<span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>做简单的魂穿假设，蚂蚁之间碰撞之时，方向不改变，但个体的性质发生变化</li><li>分析<ul><li>首先以感染源蚂蚁为核心，按是否可能被感染将左右两边的蚂蚁进行分类</li><li>判断感染源蚂蚁的行进方向，进行最终被感染蚂蚁的计算</li></ul></li></ol><h3 id="饮料换购"><a href="#饮料换购" class="headerlink" title="饮料换购"></a>饮料换购</h3><p>乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。</p><p>请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h4><p>输入一个整数 n,表示初始买入的饮料数量。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h4><p>输出一个整数，表示一共能够喝到的饮料数量。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h4><p>0&lt;n&lt;10000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a><strong>输入样例：</strong></h4><p>100</p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a><strong>输出样例：</strong></h4><p>149</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a><strong>题解</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">int</span> res = n;<br>    <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">3</span>)<br>    &#123;<br>        res += n/<span class="hljs-number">3</span>;<br>        n = (n/<span class="hljs-number">3</span>) + (n%<span class="hljs-number">3</span>);<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li><p>注意这是一个上下取整问题</p></li><li><p>注意每次都要尽可能将瓶盖换掉，不到多余</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法中的数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 2</title>
    <link href="/2022/03/02/ACDaily/ACDaily-2/"/>
    <url>/2022/03/02/ACDaily/ACDaily-2/</url>
    
    <content type="html"><![CDATA[<h1 id="二分与前缀和的练习"><a href="#二分与前缀和的练习" class="headerlink" title="二分与前缀和的练习"></a>二分与前缀和的练习</h1><h2 id="分巧克力"><a href="#分巧克力" class="headerlink" title="分巧克力"></a>分巧克力</h2><p>儿童节那天有 K位小朋友到小明家做客。</p><p>小明拿出了珍藏的巧克力招待小朋友们。</p><p>小明一共有 N 块巧克力，其中第 ii 块是 Hi×Wi 的方格组成的长方形。</p><p>为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。</p><p>切出的巧克力需要满足：</p><ol><li>形状是正方形，边长是整数</li><li>大小相同</li></ol><p>例如一块 6×6 的巧克力可以切出 66 块 2×2 的巧克力或者 2 块 3×3 的巧克力。</p><p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 K。</p><p>以下 N 行每行包含两个整数 Hi 和 Wi。</p><p>输入保证每位小朋友至少能获得一块 1×1 的巧克力。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出切出的正方形巧克力最大可能的边长。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,K≤105<br>1≤Hi,Wi≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">2<br></code></pre></div></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n, k;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> w[N], h[N];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span>  <span class="hljs-comment">// 判断条件</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        num += (w[i]/a)*(h[i]/a);  <span class="hljs-comment">// 直接去掉长度不够的巧克力，同时当巧克力满足条件也可以对能分成的小巧克力数做计算。</span><br>        <span class="hljs-keyword">if</span>(num &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 若满足条件了，直接返回成立</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; w[i] &gt;&gt; h[i];<br>    <br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e5</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 所求目标值为红色区域右端</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;  <span class="hljs-comment">// 红色区域更新</span><br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>二分有点忘了，复习复习</li></ul><h2 id="激光炸弹"><a href="#激光炸弹" class="headerlink" title="激光炸弹"></a>激光炸弹</h2><p>地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。</p><p>注意：不同目标可能在同一位置。</p><p>现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。</p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><p><strong>输入格式</strong><br>第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</p><p><strong>输出格式</strong><br>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><p><strong>数据范围</strong><br>0≤R≤109<br>0&lt;N≤10000,<br>0≤Xi,Yi≤5000<br>0≤Wi≤1000<br><strong>输入样例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5010</span>;<br><span class="hljs-keyword">int</span> p, q;<br><span class="hljs-keyword">int</span> s[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, R;<br>    cin &gt;&gt; n &gt;&gt; R;<br>    R = <span class="hljs-built_in">min</span>(<span class="hljs-number">5001</span>, R);<br>    p = q = R;<br>    <br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">int</span> x, y, w;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>        x++, y++;<br>        p = <span class="hljs-built_in">max</span>(x, p);<br>        q = <span class="hljs-built_in">max</span>(y, q);<br>        s[x][y] += w;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= q; j++)<br>            s[i][j] += s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = R; i &lt;= p; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = R; j &lt;= q; j++)&#123;<br>            sum = <span class="hljs-built_in">max</span>(sum, s[i][j]-s[i-R][j]-s[i][j-R]+s[i-R][j-R]);<br>        &#125;<br>        <br>    cout &lt;&lt; sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>巧妙利用炸弹位置的合理性处理遍历范围减少遍历范围能够优化程序运行速度</p></li><li><p>二维前缀和的一个非常好的案例</p></li></ul><h2 id="K倍区间"><a href="#K倍区间" class="headerlink" title="K倍区间"></a>K倍区间</h2><p>给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。</p><p>你能求出数列中总共有多少个 K 倍区间吗？</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h4><p>第一行包含两个整数 N 和 K。</p><p>以下 N 行每行包含一个整数 Ai。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h4><p>输出一个整数，代表 K 倍区间的数目。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a><strong>数据范围</strong></h4><p>1≤N,K≤100000,<br>1≤Ai≤100000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a><strong>输入样例：</strong></h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a><strong>输出样例：</strong></h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">6<br></code></pre></div></td></tr></table></figure><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br>LL s[N], cnt[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    LL res = <span class="hljs-number">0</span>;<br>    cnt[<span class="hljs-number">0</span>]++;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        cin &gt;&gt; s[i];<br>        s[i] += s[i<span class="hljs-number">-1</span>];<br>        res += cnt[s[i]%k];<br>        cnt[s[i]%k]++;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>本题最关键的一步在于利用前缀和将区间和表示为前缀和的差的形式，这样的话，如果区间和是k的倍数，那么两个前缀和应该是同余的，也就是说如果前缀和模k的余数相同，那么二者之间的差值一定是k的倍数。运用这种方法，有以下效果：<br>$$<br>O(n^2)-&gt;O(n)<br>$$<br>拒绝溢出。</p>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分与前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACDaily 1</title>
    <link href="/2022/03/01/ACDaily/ACDaily-1/"/>
    <url>/2022/03/01/ACDaily/ACDaily-1/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和模板题"><a href="#前缀和模板题" class="headerlink" title="前缀和模板题"></a>前缀和模板题</h1><h2 id="1-前缀和"><a href="#1-前缀和" class="headerlink" title="1. 前缀和"></a>1. 前缀和</h2><p>输入一个长度为 n 的整数序列。</p><p>接下来再输入 m 个询问，每个询问输入一对 l,r。</p><p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤l≤r≤n,<br>1≤n,m≤100000<br>−1000≤数列中元素的值≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">3<br>6<br>10<br></code></pre></div></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> a[N], s[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, num, l, r;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        cin &gt;&gt; num;<br>        a[i] = num;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) s[i] = s[i<span class="hljs-number">-1</span>] + a[i];<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; s[r] - s[l<span class="hljs-number">-1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>不构建前缀和数组只能通过6个数据</li><li>使用C输入输出能够大大提高程序运行速度</li></ul><hr><h2 id="2-子矩阵和"><a href="#2-子矩阵和" class="headerlink" title="2. 子矩阵和"></a>2. 子矩阵和</h2><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n，m，q。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2表示一组询问。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行输出一个询问的结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000,<br>1≤q≤200000<br>1≤x1≤x2≤n<br>1≤y1≤y2≤m<br>−1000≤矩阵内元素的值≤1000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">17<br>27<br>21<br></code></pre></div></td></tr></table></figure><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> a[N][N], s[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, q, k;<br>    <span class="hljs-keyword">int</span> x1, y1, x2, y2;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>            cin &gt;&gt; k;<br>            a[i][j] = k;<br>        &#125;<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>        <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        cout &lt;&lt; s[x2][y2]-s[x1<span class="hljs-number">-1</span>][y2]-s[x2][y1<span class="hljs-number">-1</span>]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>在构建前缀和时要注意运用递推的思想，不能陷入循环</li></ul>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针、BFS和图论</title>
    <link href="/2022/03/01/ACDaily/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/01/ACDaily/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法、BFS与图论"><a href="#双指针算法、BFS与图论" class="headerlink" title="双指针算法、BFS与图论"></a>双指针算法、BFS与图论</h1><h2 id="1-双指针算法"><a href="#1-双指针算法" class="headerlink" title="1.双指针算法"></a>1.双指针算法</h2><p>通常考虑遍历所有区间时会用到这种算法，比如需要枚举一段时间内的所有定长时间段，由于在时间轴上两个时间段会有大部分位置的重合，因此每次可以减少一个头部时刻，增加一个尾部时刻来实现时间段的时序枚举。实际上，这个算法是对类似以下语法结构的优化：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++)<br></code></pre></div></td></tr></table></figure><h3 id="eg-日志统计"><a href="#eg-日志统计" class="headerlink" title="eg.日志统计"></a>eg.日志统计</h3><p>小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。</p><p>其中每一行的格式是：</p><p>ts id<br>表示在 ts 时刻编号 id 的帖子收到一个”赞”。</p><p>现在小明想统计有哪些帖子曾经是”热帖”。</p><p>如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。</p><p>具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。</p><p>给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 N,D,K。</p><p>以下 N 行每行一条日志，包含两个整数 ts 和 id。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按从小到大的顺序输出热帖 id。</p><p>每个 id 占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤K≤N≤105,<br>0≤ts,id≤105,<br>1≤D≤10000</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-keyword">int</span> n, d, k;<br>PII logs[N];<br><span class="hljs-keyword">bool</span> st[N];<br><span class="hljs-keyword">int</span> cnt[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;d, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;logs[i].x, &amp;logs[i].y);<br>    <br>    <span class="hljs-built_in">sort</span>(logs, logs + n);<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> id = logs[i].y;<br>        cnt[id]++;<br>        <br>        <span class="hljs-keyword">while</span>(logs[i].x - logs[j].x &gt;= d)<br>        &#123;<br>            cnt[logs[j].y]--;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(cnt[id] &gt;= k) st[id] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(st[i]) cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-宽度优先搜索BFS"><a href="#2-宽度优先搜索BFS" class="headerlink" title="2.宽度优先搜索BFS"></a>2.宽度优先搜索BFS</h2><p>一组数，整合为数状，使用队列来辅助操作，从树根出发，若队列非空，取队头，用队头的两个儿子来入队更新队列，直至队列为空，这样就对树进行了宽度优先搜索。</p><blockquote><p>bfs常用于迷宫问题，bfs相对于dfs可以找到一条最短路径</p></blockquote><h3 id="eg-献给阿尔吉侬的花束"><a href="#eg-献给阿尔吉侬的花束" class="headerlink" title="eg.献给阿尔吉侬的花束"></a>eg.献给阿尔吉侬的花束</h3><p>阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。</p><p>今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。</p><p>现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。</p><p>迷宫用一个 R×C 的字符矩阵来表示。</p><p>字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。</p><p>阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个正整数 T，表示一共有 T 组数据。</p><p>每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。</p><p>接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。</p><p>若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。</p><p>每组数据的输出结果占一行。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1&lt;T≤10,<br>2≤R,C≤200</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>3<br>3 4<br>.S..<br>###.<br>..E.<br>3 4<br>.S..<br>.E..<br>….<br>3 4<br>.S..<br>####<br>..E.</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>5<br>1<br>oop!</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">210</span>;<br><br><span class="hljs-keyword">int</span> t, r, c;<br><span class="hljs-keyword">char</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N][N];<br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(PII start, PII end)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    dist[start.x][start.y] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x = t.x + dx[i], y = t.y + dy[i];<br>            <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= r || y &lt; <span class="hljs-number">0</span> || y &gt;= c) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(dist[x][y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            dist[x][y] = dist[t.x][t.y] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">make_pair</span>(x, y) == end) <span class="hljs-keyword">return</span> dist[x][y];<br>            q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;r, &amp;c);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, g[i]);<br>        <br>        PII start, end;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;S&#x27;</span>) start = &#123;i, j&#125;;<br>                <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;E&#x27;</span>) end = &#123;i, j&#125;;<br>            &#125;<br>            <br>        <span class="hljs-keyword">int</span> distance = <span class="hljs-built_in">bfs</span>(start, end);<br>        <span class="hljs-keyword">if</span>(distance == <span class="hljs-number">-1</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;oop!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, distance);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-图论"><a href="#3-图论" class="headerlink" title="3.图论"></a>3.图论</h2><p>判重数组使得每个点最多只会被遍历一次</p><h3 id="eg-交换瓶子"><a href="#eg-交换瓶子" class="headerlink" title="eg.交换瓶子"></a>eg.交换瓶子</h3><p>有 N 个瓶子，编号 1∼N，放在架子上。</p><p>比如有 5 个瓶子：</p><p>2 1 3 5 4<br>要求每次拿起 2 个瓶子，交换它们的位置。</p><p>经过若干次后，使得瓶子的序号为：</p><p>1 2 3 4 5<br>对于这么简单的情况，显然，至少需要交换 2 次就可以复位。</p><p>如果瓶子更多呢？你可以通过编程来解决。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N，表示瓶子数量。</p><p>第二行包含 N 个整数，表示瓶子目前的排列状况。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，表示至少交换多少次，才能完成排序。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤10000,</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><p>5<br>3 1 2 5 4</p><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><p>3</p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><p>5<br>5 4 3 2 1</p><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><p>2</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> w[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; w[i];<br><br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])<br>        &#123;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; !st[j]; j = w[j]) st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n - cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACDaily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>宽搜</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言实现贪吃蛇</title>
    <link href="/2022/02/28/Project/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87/"/>
    <url>/2022/02/28/Project/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘要：贪吃蛇是我们从小玩到大的小游戏，本次实训以此为载体，将Go语言的基本语法与使用规范进行展示。同时在报告中也会对Go语言的独有特性进行介绍。</p></blockquote><p><strong>一.项目分析</strong></p><p>(一)贪吃蛇玩法：</p><p>在一定区域内通过上下左右方向键控制蛇的方向，寻找食物，吃到食物后获得积分，并且蛇的身子变长，蛇不能碰墙与自己的身体。</p><p>(二)项目模块分析：</p><p>1.蛇模块</p><p>Ø 初始化蛇（出生）</p><p>Ø 蛇移动</p><p>Ø 碰撞食物，长度改变</p><p>Ø 碰撞墙或自己，蛇死亡</p><p>2.食物模块</p><p>Ø 食物产生</p><p>Ø 食物消失</p><p>3.游戏控制</p><p>Ø 控制键盘输入</p><p>Ø 游戏流程</p><p>4.游戏显示</p><p>Ø 游戏地图显示</p><p><strong>（三）流程初定</strong></p><p>基于以上的项目模块分析，我们可以初步确定项目实现的基本流程，在之后的每一步再不断优化下一步的处理。具体的流程如下：构建地图、食物类、蛇类 -&gt; 图形显示器 -&gt; 初始化地图信息 -&gt; 初始化蛇信息 -&gt; 设计食物随机产生器-&gt; 设计游戏逻辑 -&gt; 设计主程序。</p><p><strong>二.项目的实现</strong></p><p>文件结构：</p><p>$GOPATH: src\she.go</p><p>$GOROOT: src\Clib\Clib.go</p><p><strong>（一）地图、蛇类、食物类的构造</strong></p><p>1.地图设置</p><p>  作为一个合理的贪吃蛇游戏，同时考虑我们的贪吃蛇小游戏是在命令行中实现的。因此我们考虑全局声明地图的长和高，且将它们初始化为20。这样我们就可以在main包中的任意位置合理地调用它们。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">Package main<br>Import … <br><span class="hljs-keyword">const</span> WIDE <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span>  <span class="hljs-comment">// 设置布局</span><br><span class="hljs-keyword">const</span> HIGH <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>2.蛇类与食物类设置</p><p>  作为一款贪吃蛇小游戏，主角当然是我们的小蛇。小蛇有它的长度size，有运动方向dir（小蛇是有头有尾的）。那么，要将小蛇的长度与方向这两个外部显示属性进行修改并显示，就需要引入一个能够对小蛇位置进行控制的数据结构——数组。这个数组中存放着小蛇每一节的位置坐标，考虑到小蛇的运动自由性，我们可以将数组的容量设置为地图的大小即20*20 = 400。</p><p>作为贪吃蛇小游戏的次角——食物就没有那么多的信息，不过在后期可以对它的ui进行一个美化。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Snake <span class="hljs-keyword">struct</span>&#123;<br>    size <span class="hljs-keyword">int</span><br>    dir <span class="hljs-keyword">byte</span><br>    pos [WIDE*HIGH]Position<br>&#125;<br><br><span class="hljs-keyword">type</span> Food <span class="hljs-keyword">struct</span>&#123;<br>    Position<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>（二）设计图形显示器</strong></p><p>  定义好以上静态信息，如果不对它们进行外部显示，便失去了意义。考虑到我们最终设计出来的小蛇与食物的位置是在不断变化的，但每一次变化的位置可以用光标来控制，因此我们考虑用cgo即c与go语言进行混合编程来实现这一功能，因为c语言标准库中有简单的函数来实现命令行光标的移动。我们要做的仅仅是做一个接口，使得在Go中也能调用的这些c函数。</p><p>  首先，我们需要自行构建一个包，在这里我们命名为Clib。在GoRoot目录的src文件下新建一个文件夹并命名为Clib，然后在它的内部创建一个Go文件，写入以下信息：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Clib<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;windows.h&gt;</span><br><span class="hljs-comment">#include &lt;conio.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 使用了WinAPI来移动控制台的光标</span><br><span class="hljs-comment">void gotoxy(int x, int y)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    COORD c;</span><br><span class="hljs-comment">    c.X = x, c.Y = y;</span><br><span class="hljs-comment">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 从键盘获取一次按键，但不显示到控制台</span><br><span class="hljs-comment">int direct()</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    return _getch();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">//去掉控制台光标</span><br><span class="hljs-comment">void hideCursor()</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    CONSOLE_CURSOR_INFO  cci;</span><br><span class="hljs-comment">    cci.bVisible = FALSE;</span><br><span class="hljs-comment">    cci.dwSize = sizeof(cci);</span><br><span class="hljs-comment">    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cci);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-comment">//设置控制台光标位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GotoPosition</span><span class="hljs-params">(X <span class="hljs-keyword">int</span>, Y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">//调用C语言函数</span><br>    C.gotoxy(C.<span class="hljs-keyword">int</span>(X), C.<span class="hljs-keyword">int</span>(Y))  <span class="hljs-comment">// go类型转换</span><br>&#125;<br><span class="hljs-comment">//无显获取键盘输入的字符</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Direction</span><span class="hljs-params">()</span> <span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    key = <span class="hljs-keyword">int</span>(C.direct())<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">//设置控制台光标隐藏</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HideCursor</span><span class="hljs-params">()</span></span> &#123;<br>    C.hideCursor()<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>注意包头要注明package Clib，之后在Clib文件夹中新建的Go文件也是如此，这类似于一个归属标识，不可缺少。</p><p>/<em>与</em>/包裹的部分是C语言，也是Go中可以调用的函数的一个本源映射， 标准的头文件引入与函数定义都是需要的，与C中语法相同。一个要注意的点是import “C”与上面的C语言引用说明间是不能有空行的，否则在之后的主文件包调用中会报错；还有Go函数的名称一定要大写，这与后期调用有密切关系。通过以上两点我们可以看到Go语言对格式的高规范、高要求。</p><p>设计好我们需要的包后，就需要在主文件中调用采用使用其中的函数。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;Clib&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br></code></pre></div></td></tr></table></figure><p>  回到正题，我们需要将命令行光标移动到蛇与食物的每个位置来设置它们的ui，因此我们在这里用的是用C设计的gotoxy函数与Go设计的GotoPosition函数。在主文件中，我们定义函数showUI，接口设置为目标（蛇或食物）的位置坐标与需要设置的ui图形。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShowUI</span><span class="hljs-params">(X <span class="hljs-keyword">int</span>, Y <span class="hljs-keyword">int</span>, ui <span class="hljs-keyword">byte</span>)</span></span>&#123;<br>    <span class="hljs-comment">// 找到对应坐标点光标位置</span><br>    Clib.GotoPosition(X*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,Y+<span class="hljs-number">2</span>)  <span class="hljs-comment">// 避免蛇移动影响棋盘边界</span><br>    <span class="hljs-comment">// 绘制图形</span><br>    fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;%c&quot;</span>, ui)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>(三)初始化地图信息</p><p>  地图的初始化是简单的，我们仅需将一个方框打印出来，由于篇幅有限这里只做出来它的简化图：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapInit</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Fprintln(os.Stderr,<span class="hljs-string">`</span><br><span class="hljs-string">    #------#</span><br><span class="hljs-string">    |       |</span><br><span class="hljs-string">    |       |</span><br><span class="hljs-string">    #------#</span><br><span class="hljs-string">    `</span>)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>可以想象一下，实际上水平方向有40个“-”，竖直方向有20个“|”。</p><p>这里采用了一个特殊函数Fprintln，对比ShowUI中的Fprintf，我们可以看到其中的相似与差别:</p><table><thead><tr><th>Fprintf</th><th>Fprintf 根据 format 参数生成格式化的字符串并写入 w 。返回写入的字节数和遇到的任何错误。</th></tr></thead><tbody><tr><td>Fprintln</td><td>Fprintln 采用默认格式将其参数格式化并写入 w 。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。</td></tr></tbody></table><p>**(**<strong>四)初始化蛇信息</strong></p><p>1.初始化蛇的长度、方向与位置，并绘制初始形态</p><p>  通常，贪吃蛇的开端是地图的中心，长度为2（包括一头一尾），并且头朝右，尾与头在一条水平面上，我们的游戏也是如此。</p> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s.size = <span class="hljs-number">2</span>  <span class="hljs-comment">// 一头一尾</span><br>    s.dir = <span class="hljs-string">&#x27;R&#x27;</span>  <span class="hljs-comment">//初始化方向 用UDLR做上下左右</span><br>    s.pos[<span class="hljs-number">0</span>].X = WIDE/<span class="hljs-number">2</span><br>    s.pos[<span class="hljs-number">0</span>].Y = HIGH/<span class="hljs-number">2</span><br>    s.pos[<span class="hljs-number">1</span>].X = WIDE/<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>s.pos[<span class="hljs-number">1</span>].Y = HIGH/<span class="hljs-number">2</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.size; i++&#123;<br>        <span class="hljs-keyword">var</span> ui <span class="hljs-keyword">byte</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>&#123;<br>            ui = <span class="hljs-string">&#x27;@&#x27;</span><br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            ui = <span class="hljs-string">&#x27;*&#x27;</span><br>        &#125;<br>        ShowUI(s.pos[i].X, s.pos[i].Y, ui)<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>2.设置蛇方向的调整方式</p><p>  考虑到玩家在游戏中唯一的操作就是不断改变蛇的移动方向，那么我们就需要建立按键与方向之间的联系。在本模块的设计中需要查找ASCII码与字符间的对应关系。“WSAD”是我们玩游戏时常用的按键，因此我们将它们与方向“上下左右”建立关系，但有时候用户可能会忽视它们的键盘大写设置，或者因外界因素导致某些键位损坏，因此我们也将”wsad”与”udrl”加入了设计。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-keyword">switch</span> Clib.Direction() &#123;<br>            <span class="hljs-comment">//方向上  W|w|↑</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">83</span>, <span class="hljs-number">115</span>, <span class="hljs-number">80</span>:<br>                s.dir = <span class="hljs-string">&#x27;U&#x27;</span><br>                <span class="hljs-comment">//方向左</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>, <span class="hljs-number">97</span>, <span class="hljs-number">75</span>:<br>                s.dir = <span class="hljs-string">&#x27;L&#x27;</span><br>                <span class="hljs-comment">//方向右</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>, <span class="hljs-number">68</span>, <span class="hljs-number">77</span>:<br>                s.dir = <span class="hljs-string">&#x27;R&#x27;</span><br>                <span class="hljs-comment">//方向下</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">72</span>, <span class="hljs-number">87</span>, <span class="hljs-number">119</span>:<br>                s.dir = <span class="hljs-string">&#x27;D&#x27;</span><br>                <span class="hljs-comment">//暂停  空格键</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:<br>                s.dir = <span class="hljs-string">&#x27;P&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;()  <span class="hljs-comment">// 特殊的独立函数</span><br><br></code></pre></div></td></tr></table></figure><p>这是一个特殊的函数，它独立于main，在程序运行过程中始终保持生效状态。</p><p><strong>（五）设计食物随机产生器</strong></p><p>   由于贪吃蛇中的食物是随机产生的，我们需要赋予食物的位置一个随机性。但Go的rand包在边界范围内产生的随机种子不是随机的，因此我们需要在main中加入混淆种子来实现随机性。</p> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RandomFood</span><span class="hljs-params">()</span></span>&#123;<br>    food.X = rand.Intn(WIDE)+<span class="hljs-number">1</span>  <span class="hljs-comment">// 直接写起不到随机的效果,这是go的一个缺点</span><br>    food.Y = rand.Intn(HIGH)+<span class="hljs-number">1</span><br>    ShowUI(food.X, food.Y, <span class="hljs-string">&#x27;s&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置一个随机种子，用作混淆</span><br>    rand.Seed(time.Now().UnixNano())<br><br></code></pre></div></td></tr></table></figure><p>注意函数定义在main外，混淆种子定义在main内。</p><p><strong>（六）设置游戏逻辑</strong></p><p>  在游戏开始时，我们就可以对贪吃蛇的方向进行调整，我们在之前已经对键位与贪吃蛇移动方向进行了联系，接下来我们来实现它的动态效果：</p> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nx, ny <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">switch</span> s.dir &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;U&#x27;</span>:<br>            nx = <span class="hljs-number">0</span><br>            ny = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>            nx = <span class="hljs-number">0</span><br>            ny = <span class="hljs-number">-1</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>            nx = <span class="hljs-number">-1</span><br>            ny = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>            nx = <span class="hljs-number">1</span><br>            ny = <span class="hljs-number">0</span><br>        &#125;<br><br></code></pre></div></td></tr></table></figure><p>这一部分包含在一个永真循环中，每一次循环，蛇的方向可能都不一样，不同的方向会对应蛇头的位移，紧接着链式反应到蛇身。</p><p>众所周知，贪吃蛇有两种死亡方式，那就是头撞墙或撞到自己的身体，在这里我们可以用使用位置信息来进行判断：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 蛇头和墙体碰撞判断</span><br>        <span class="hljs-keyword">if</span> s.pos[<span class="hljs-number">0</span>].X &lt; <span class="hljs-number">1</span> || s.pos[<span class="hljs-number">0</span>].Y &lt; <span class="hljs-number">1</span> || s.pos[<span class="hljs-number">0</span>].X &gt;= WIDE+<span class="hljs-number">1</span> || s.pos[<span class="hljs-number">0</span>].Y &gt;= HIGH+<span class="hljs-number">1</span>&#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 蛇头和身体判断</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; s.size; i++&#123;<br>            <span class="hljs-keyword">if</span> s.pos[<span class="hljs-number">0</span>].X == s.pos[i].X &amp;&amp; s.pos[<span class="hljs-number">0</span>].Y == s.pos[i].Y&#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 蛇跟食物判断</span><br>        <span class="hljs-keyword">if</span> s.pos[<span class="hljs-number">0</span>].X == food.X &amp;&amp; s.pos[<span class="hljs-number">0</span>].Y == food.Y&#123;<br>            <span class="hljs-comment">// 身体增长</span><br>            s.size++<br>            <span class="hljs-comment">// 刷新食物位置</span><br>            RandomFood()<br>            <span class="hljs-comment">// 分数变量</span><br>        &#125;<br><br></code></pre></div></td></tr></table></figure><p>在贪吃蛇世界中，有且仅会发生以上三种碰撞。当贪吃蛇吃到食物，它的各项属性会发生相应的变化：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//获取蛇尾坐标,在之后隐去蛇尾</span><br>        wx := s.pos[s.size<span class="hljs-number">-1</span>].X<br>        wy := s.pos[s.size<span class="hljs-number">-1</span>].Y<br><br>        <span class="hljs-comment">// 从尾部开始更新蛇的身体坐标</span><br>        <span class="hljs-keyword">for</span> i := s.size<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>            s.pos[i].X = s.pos[i<span class="hljs-number">-1</span>].X<br>            s.pos[i].Y = s.pos[i<span class="hljs-number">-1</span>].Y<br>        &#125;<br><br>        <span class="hljs-comment">// 更新蛇头坐标</span><br>        s.pos[<span class="hljs-number">0</span>].X += nx<br>        s.pos[<span class="hljs-number">0</span>].Y += ny<br><br>        <span class="hljs-comment">//绘制蛇</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; s.size; i++&#123;<br>            <span class="hljs-keyword">var</span> ui <span class="hljs-keyword">byte</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>&#123;<br>                ui = <span class="hljs-string">&#x27;@&#x27;</span><br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                ui = <span class="hljs-string">&#x27;*&#x27;</span><br>            &#125;<br>            ShowUI(s.pos[i].X, s.pos[i].Y, ui)<br>        &#125;<br><span class="hljs-comment">// 重新绘制图形</span><br>        ShowUI(wx, wy, <span class="hljs-string">&#x27; &#x27;</span>)<br><br></code></pre></div></td></tr></table></figure><p>这里要先更新蛇尾再更新蛇头，否则会导致异形蛇的产生。再更新完蛇的位置坐标后，会重新绘制蛇形。</p><p><strong>（七）设计主程序</strong></p><p>  待所有的工具模块设计好后，我们就可以设计主程序的流程了。首先，我们初始化地图，然后有了地图，就利用随机种子生成食物，这一点我们在设计食物随机生成器提到过，还需要加入混淆种子来赋予随机性。之后，我们需要隐藏命令行光标，减小对游戏体验的影响，具体的，需要利用Clib包内的HideCursor函数。最后，就是对蛇的设计，首先我们初始化蛇，然后再将蛇置入游戏中。具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 设置一个随机种子，用作混淆</span><br>    rand.Seed(time.Now().UnixNano())<br>    <span class="hljs-comment">// 隐藏光标</span><br>    Clib.HideCursor()<br>    <span class="hljs-comment">// 初始化地图</span><br>    MapInit()<br>    <span class="hljs-comment">// 生成随机食物</span><br>    RandomFood()<br>    <span class="hljs-comment">// 绘制食物</span><br>    <span class="hljs-comment">//ShowUI(food.X, food.Y, &#x27;s&#x27;)</span><br><br>    <span class="hljs-keyword">var</span> s Snake<br>    s.SnakeInit()<br><br>    s.PlayGame()<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>三.项目总结</strong></p><p>  本项目已上传至Github，欢迎体验与交流。</p><p>地址是：<a href="https://github.com/huansong-dev/GluttonousSnake-Go">https://github.com/huansong-dev/GluttonousSnake-Go</a></p><p>以上就是本项目的全部后台设计。在未来，我们还可以为游戏加入更多模式，或增加难度，例如增加障碍、不断加快速度等等。</p><p>面向业务、面向需求，不断打磨、不断优化是每一个设计者都需要具有的能力。作为一名优秀的coder，需要匠心独运。</p><p><strong>四.参考文献</strong></p><p>[1] 【六星教育】G0语言综合实战贪吃蛇项目开发教学[EB/OL].[2021-04-27].<a href="https://www.bilibili.com/video/BV1tA411V7aH?p=4">https://www.bilibili.com/video/BV1tA411V7aH?p=4</a></p><p>[2]Golang实现贪吃蛇[EB/OL].[2018-08-12]. <a href="http://t.csdn.cn/XLYO3">http://t.csdn.cn/XLYO3</a></p><p>[3] Go语言文档[EB/OL].[2022-02-26]. <a href="https://go.dev/doc/">https://go.dev/doc/</a></p><p>[TOC]</p>]]></content>
    
    
    <categories>
      
      <category>Go Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信奥传奇——杜瑜皓</title>
    <link href="/2022/02/16/Examples/%E4%BF%A1%E5%A5%A5%E4%BC%A0%E5%A5%87%E2%80%94%E2%80%94%E6%9D%9C%E7%91%9C%E7%9A%93/"/>
    <url>/2022/02/16/Examples/%E4%BF%A1%E5%A5%A5%E4%BC%A0%E5%A5%87%E2%80%94%E2%80%94%E6%9D%9C%E7%91%9C%E7%9A%93/</url>
    
    <content type="html"><![CDATA[<h1 id="信奥传奇——杜瑜皓"><a href="#信奥传奇——杜瑜皓" class="headerlink" title="信奥传奇——杜瑜皓"></a>信奥传奇——杜瑜皓</h1><p>他从小开始学习信息学，从初中到高中几起几落、经历坎坷终得回报。他曾因为 NOI 金牌入选国家集训队保送清华，在 IOI 2015 中代表中国队出战拿下金牌，大学期间拿下 CCPC 全国总冠军、 Facebook Hacker Cup 全球亚军、ACM-ICPC 2017 全球总决赛第六名、Topcoder TCO17 全球总冠军。他就是我们今天信奥传奇的主人公——杜瑜皓。</p><p><strong>从小学习信息学 初二全国赛夺银</strong></p><p>小学时候的杜瑜皓是一个对数学非常感兴趣的孩子，当很多还在纠结四则运算的时候，在父亲的引导下，杜瑜皓已经提前学习了很多中学甚至是大学的数学内容。</p><p>小学四年级时，当时只有 10 岁的杜瑜皓报名了学校举办的程序设计辅导班。在这个班上，杜瑜皓认识了很多和他类似、对数学很感兴趣的孩子们，和一群志同道合的人一起学习编程、学习信息学给了当时的他一种归属感。自此开始，杜瑜皓就迷上了信息学，走上了一条“神奇的道路”。</p><p>进入初中后，2009 年杜瑜皓在 NOIP 普及组中就已经获得了不错的成绩，在省内的选手中凸显了出来。2010 年时，刚上初二的杜瑜皓开始在 NOIP 提高组中崭露头角，以 340 分的成绩成为了当年浙江省 NOIP 提高组一等奖中年龄最小的获奖选手。</p><p>次年，经过省队选拔考试，杜瑜皓顺利进入了浙江省省队。代表浙江出战全国赛 NOI 2011 的杜瑜皓获得了一块银牌。在杜瑜皓眼中，他依然觉得自己当时“发挥得不太好”。</p><p>不过，这次初中阶段的 NOI 的经历让杜瑜皓认识了很多优秀的选手，特别是一些已经保送清华的学长。看到这些优秀的人，杜瑜皓当时就坚定了自己将来有一天去清华学习的信念。</p><p><strong>挫败后拿到清华一本线录取：还继续竞赛吗？</strong></p><p>从初二开始，杜瑜皓已经成长成了一个“一等奖专业户”，每年到时间拿下 NOIP 提高组一等奖已经成了一个习惯性动作。在 NOI 2011 获得银牌、NOI 2012 获得银牌并入选国家集训队（备注：当时国家集训队为 60 人，含部分银牌选手）。</p><p>很多进入国家集训队的竞赛选手会选择停课专心训练，但是杜瑜皓不想这么做。高中进入镇海中学之后，杜瑜皓选择每天晚自习和周末的时间用来完成国家集训队的作业。</p><p>高一时，照常拿下提高组一等奖的杜瑜皓却突然发挥失常，没能进入省队，失去了 NOI 2013 的正式选手资格。在后来的冬令营比赛中，因为一个微小的失误，已经入选国家集训队的他又与国家队失之交臂。</p><p>杜瑜皓当时曾总结——“那段时间自己不知道怎么了，总是连连失误，可能是之前太顺利了，就自我膨胀了。”</p><p>在 NOI 2013 的赛场上，杜瑜皓作为邀请赛选手参赛，获得 519 分的高分。虽然因为没有前一年的 NOIP 一等奖成绩而导致不能直接保送，但依然获得了清华大学“高考一本线录取资格”。</p><p>在包括学校老师和杜瑜皓父母在内的在很多人看来，获得清华大学“高考一本线录取资格”应该就很好了。父母期待他接下来应该稳重一些，准备高考，均衡发展，两边兼顾。学校也希望他能好好补上落下的文化课，并希冀他参加高考搏一搏状元的位置。</p><p>但杜瑜皓太爱信息学了，他心中还是想要继续参加竞赛，希望自己在哪里摔倒就还在哪里爬起来，在竞赛中继续证明和超越自己。</p><p>可是，他也知道孤注一掷风险很大——没时间顾及文化课可能导致自己最终高考用不上清华大学“高考一本线录取资格”；而通过竞赛取得保送资格又只剩下高二这一次机会了。</p><p>最终，杜瑜皓选择了“脚踏两条船”，在白天学习文化课，在晚上晚自习的时间抽空去机房练习信息学竞赛。然而，高二的期中考试中，杜瑜皓的成绩一下从前几下滑到了四十多名，班主任老师赶忙找他谈话，希望他不再去机房做题了。</p><p>虽然知道老师是为他好，但是杜瑜皓实在不甘心，因为从小学四年级到现在，信息学竞赛已经成为他生活的一部分。为此，他决定压缩自己的睡眠时间，每天白天和晚自习都放在文化课上，晚上回到出租屋后少睡两小时做题、保持竞技状态。努力终有回报，期末时，杜瑜皓的成绩重新回到了年级第三的位置。</p><p><strong>认真地爱信息学 努力一搏为国争光</strong></p><p>高一期间竞赛场上接连的失误让杜瑜皓有一些发慌，他此前积累的所有先发优势一下子荡然无存，想全国夺金取得保送资格就只剩下高二这一次机会了。高二开学后不久的 NOIP 提高组比赛上，杜瑜皓稳定发挥，考出了一个不错的成绩，并在之后通过省选重回省队。</p><p>再度代表浙江出战 NOI 的杜瑜皓心中很清楚——想拿全国金牌只有最后一次机会了。他考试前很是紧张，还犯了急性肠胃炎。在被采访时他曾介绍：“我上吐下泻的，挂盐水到了夜里十点多，睡觉睡不沉稳，做着奇怪的噩梦，我实在没想到会遇到这种情况，以这种方式来完成自己的最后一次比赛，真是感觉到了命运弄人。”</p><p>老天还是眷顾杜瑜皓的，虽然临场状态不佳，但他却拿下了全场第二名的好成绩获得了他梦寐以求的 NOI 金牌，再度进入国家集训队并获得保送资格。</p><p>高三的时候，通过层层选拔，杜瑜皓成为了国家队四位成员之一并代表中国出战在哈萨克斯坦阿拉木图举办的 IOI 2015 第 27 届国际信息学竞赛。杜瑜皓最终取得全球第四名的成绩并获得金牌。</p><p><img src="https://5b0988e595225.cdn.sohucs.com/q_70,c_zoom,w_640/images/20180510/b083016639f840e7a3ec62894e022d9a.webp" alt="img"></p><p>代表中国队出战 IOI 2015 的杜瑜皓（右三）</p><p>获奖后的杜瑜皓并不满足：“很想为祖国荣誉而战，拿个第一回来争光，但结果还是有些遗憾。我在考场上甚至怀疑会呕吐然后不能继续进行比赛。尽管最后的结果不算差，但和我预期的差了很多。正如领队老师们所说的，适应环境的能力也是个人能力的一环。有的时候总感觉艺术作品以悲剧结局或者不那么完美更有美感，但是在自己身上，还是不能去坦然地欣赏了。</p><p><strong>在清华：竞赛不能停，生活更有趣</strong></p><p>竞赛，竞赛，竞赛，杜瑜皓的生活中几乎全是竞赛。他自己也曾经无数次思考，这样的选择到底值不值得。</p><p>“还是有一点点后悔的，不光是最后一次 OI 的比赛成绩不如自己的设想，主要还是因为一直过分专注于竞赛，而错过了去体会生活本来的滋味和颜色”。</p><p>进入清华后，杜瑜皓让自己的生活中也增加了一些闲暇的部分：“春和日丽，去水木清华的荷塘一带散散步就是一大乐事，尤其是夜里，想象着朱自清，清风徐徐，让人身心愉悦，能忘掉很多不开心的事情。”</p><p>但是，让自己多一些空闲时间并不意味着放弃奋斗。在清华，杜瑜皓还希望更多地去挑战，尽自己所能去开拓、去发现新的可能性和新的生活的颜色。</p><p>保送入清华大学计算机系以后，杜瑜皓又经过二次招生进入中国当时唯一的计算机科学实验班——姚班。在姚班课程很多，即使高中时成绩很不错的杜瑜皓也并没有觉得很自由轻松。</p><p><img src="https://5b0988e595225.cdn.sohucs.com/q_70,c_zoom,w_640/images/20180510/0c8ffb9350f8442b902774b6094e38c3.webp" alt="img"></p><p>代表清华出战 ACM-ICPC 2017 的杜瑜皓（左二）</p><p>清华的氛围大大的帮助了他，让他感觉很好：“清华的同学们各自都很有很强的知识背景，所以讨论起来非常热烈、非常深入，既能产生共鸣，又能获得新的启发。”</p><p>虽然只是本科生，杜瑜皓选修了一门开给研究生的算法设计课程，难度很大，但坚持下来让他非常有成就感。“甚至比拿金牌的感觉好多了呢，应该是目前我最喜欢的一门课程。”</p><p>同时，杜瑜皓也还在自己喜欢的竞赛道路上奔跑着，和同学组队参加 ACM-ICPC、CCPC 的竞赛，去 Facebook Hacker Cup、计蒜之道、Topcoder TCO 等比赛刷奖。拿下了 CCPC 全国总冠军、 Facebook Hacker Cup 全球亚军、ACM-ICPC 2017 全球总决赛第六名、Topcoder TCO17 算法组全球总冠军等好成绩。</p><p><img src="https://5b0988e595225.cdn.sohucs.com/q_70,c_zoom,w_640/images/20180510/e25ea5995113477da568e05a9c152c8b.webp" alt="img"></p><p>Facebook Hacker Cup 亚军的杜瑜皓（左三）</p><p>杜瑜皓说自己一直很喜欢“我命由我不由天”这句话，“虽然看上去很中二，但年轻人，怎么可以没有一点锐气。”他希望自己能通过努力逃离世界线的收束，争取将来少留些遗憾。</p><p><strong>结语</strong></p><p>现在，杜瑜皓一面在努力学习，一方面也在积极地拥抱未来。学业之余，杜瑜皓还加入了人工智能领军企业小马智行（Pony.ai）实习，参与无人车相关算法的研究。</p><p>或许，不久之后，杜瑜皓将不再把太多时间投入在比赛上，而为人类带去更多的有价值的贡献。就如他自己在高中毕业时所写——“无论如何，这一切都已经过去了。算法竞赛都不将是我人生的主要部分。”</p><blockquote><p>年轻人，不能没有锐气，而那些榜样的位置，就是我们向往的地方，追逐、超越他们，是永恒的动力之源，从初中到高中再到大学，到往后，亦是如此。</p></blockquote><p>文章转自<a href="https://m.sohu.com/a/231138618_797912">https://m.sohu.com/a/231138618_797912</a></p>]]></content>
    
    
    <categories>
      
      <category>Examples</category>
      
    </categories>
    
    
    <tags>
      
      <tag>example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何寻找第一份实习</title>
    <link href="/2022/02/05/experience(%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E7%BB%8F%E9%AA%8C)/working%20experience/%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%AE%9E%E4%B9%A0/"/>
    <url>/2022/02/05/experience(%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E7%BB%8F%E9%AA%8C)/working%20experience/%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%AE%9E%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="如何寻找第一份实习"><a href="#如何寻找第一份实习" class="headerlink" title="如何寻找第一份实习"></a>如何寻找第一份实习</h1><h2 id="找工作分为三个阶段"><a href="#找工作分为三个阶段" class="headerlink" title="找工作分为三个阶段"></a>找工作分为三个阶段</h2><ol><li>找工作前：校招前半个月</li><li>找工作中</li><li>offer到手</li></ol><h3 id="找工作前"><a href="#找工作前" class="headerlink" title="找工作前"></a>找工作前</h3><ol><li>首先要明确自己的目标，一定要选择自己喜欢的方向。</li><li>其次要确定自己想进的公司，因为我们最终的目的是找到一家能为之效力的企业。</li><li>同时要做好备胎的选择，提高自己的容错率，制作一张表格最好。</li><li>接着是可以开始制作一份简历<br><a href="https://link.zhihu.com/?target=http://cv.qiaobutang.com/">一些模版</a><br><a href="https://link.zhihu.com/?target=http://www.douban.com/note/132509263/">一些提醒</a></li><li>多关注目标公司的招聘行程<br><a href="https://link.zhihu.com/?target=http://my.yingjiesheng.com/xuanjianghui.html">校园招聘会</a><br><a href="https://link.zhihu.com/?target=http://www.dajie.com/">招聘社交平台</a></li></ol><h3 id="找工作中"><a href="#找工作中" class="headerlink" title="找工作中"></a>找工作中</h3><ol><li>宣讲会、笔试、面试</li><li>条理清楚、简洁有效，总结归纳</li><li>一定要熟悉简历</li><li>一些面试技巧<a href="http://www.zhihu.com/question/19920401">面试技巧</a></li></ol><h3 id="offer到手时"><a href="#offer到手时" class="headerlink" title="offer到手时"></a>offer到手时</h3><p>收集提供offer公司的信息，顺遂己愿做出选择。<br>关注合同与薪酬待遇<a href="https://link.zhihu.com/?target=http://www.douban.com/note/132658639/">薪酬相关</a></p>]]></content>
    
    
    <categories>
      
      <category>experience</category>
      
      <category>working experience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一点点递推与二分</title>
    <link href="/2022/01/20/algorithm/%E4%B8%80%E7%82%B9%E7%82%B9%E9%80%92%E6%8E%A8%E4%B8%8E%E4%BA%8C%E5%88%86/"/>
    <url>/2022/01/20/algorithm/%E4%B8%80%E7%82%B9%E7%82%B9%E9%80%92%E6%8E%A8%E4%B8%8E%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="AcWing116-飞行员兄弟"><a href="#AcWing116-飞行员兄弟" class="headerlink" title="AcWing116. 飞行员兄弟"></a>AcWing116. 飞行员兄弟</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>每个开关只按一次</li><li>顺序无关紧要</li><li>数据范围很小，16个位置</li><li>要求步数和字典序最小<blockquote><p>拓展：高斯消元法，T208  </p></blockquote><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3></li><li>枚举所有方案，0-2^16-1</li><li>按该方案对所有灯泡进行操作</li><li>判断灯泡是否全亮<ol><li>若全亮，记录方案<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3>vector每次定义时都会初始化为空<br>位运算方法的实用性</li></ol></li></ol><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="思想（具有普适性）"><a href="#思想（具有普适性）" class="headerlink" title="思想（具有普适性）"></a>思想（具有普适性）</h3><ol><li>确定一个区间，使得答案一定在区间内</li><li>找一个性质，满足<ol><li>性质具有二段性</li><li>答案是二段性的分界点</li></ol></li><li>判断终点M在该判断条件下是否成立</li><li>若更新方式写的是R = M则不做任何处理</li><li>若更新方式是L = M，则在计算M时+1</li><li>注意当两个端点非常接近时的合理性判断</li></ol><blockquote><p>整数二分具有离散性，需要考虑边界条件，而实数二分具有稠密性，因此边界条件可以不考虑，有单调性一定可以二分，没有单调性也有二分的可能  </p></blockquote><h3 id="红色区间右端点"><a href="#红色区间右端点" class="headerlink" title="红色区间右端点"></a>红色区间右端点</h3><p>代码方面L和R的中间值计算时分子要补1（解决计算小区间情况）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(L &lt; R)<br>&#123;<br>M = L+R+<span class="hljs-number">1</span>/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(M 红）L = M;<br><span class="hljs-keyword">else</span> R = M<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="绿色区间左端点"><a href="#绿色区间左端点" class="headerlink" title="绿色区间左端点"></a>绿色区间左端点</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>( L &lt; R)<br>&#123;<br>M = L+R/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(M 绿) R = M;<br><span class="hljs-keyword">else</span> L = M + <span class="hljs-number">1</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="eg-数的范围"><a href="#eg-数的范围" class="headerlink" title="eg.数的范围"></a>eg.数的范围</h3><ul><li>特性</li></ul><ol><li>数组长度决定了数的范围</li><li>相同数字是分布在同一区间的位置</li><li>需要建立标号(位置)与值之间的对应关系</li></ol><ul><li>步骤</li></ul><ol><li>先确定左右端点中的某个端点此处以左端点为例</li><li>目标为寻找首个大于等于x的q[mid]</li><li>构建二分查找</li><li>进行结果判断结果</li></ol>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solving note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归与递推</title>
    <link href="/2022/01/20/algorithm/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/"/>
    <url>/2022/01/20/algorithm/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
    
    <content type="html"><![CDATA[<p>递归主要在以下三种题型有所体现</p><ol><li>递归实现指数型枚举</li><li>递归实现排列型枚举</li><li>递归实现组合型枚举</li></ol><p>而<strong>分析问题-提取模型-方法尝试-代码实现</strong></p><p>这四步是解决递归问题的基本流程。</p><hr><h2 id="一-递归实现指数型枚举"><a href="#一-递归实现指数型枚举" class="headerlink" title="一. 递归实现指数型枚举"></a>一. 递归实现指数型枚举</h2><blockquote><p>从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好 1个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤ n≤ 15</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure></blockquote><p>首先理清题意，可以将问题简化为计算n元集的子集，所以关键在于考虑每个位置上的数是否存在，由于数有一定顺序，所以我们可以判别这是一个递归问题。</p><p>递归问题的关键在于实现一个递归搜索树，所以在明确本题要求后，我们可以进行一个逻辑推演，在白纸上画出如下树状图：</p><p>有了树状图的帮助，我们可以更便捷地得出每个位置上的数的选择规律。这有助于我们确定深度搜索算法的body部分。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">// 全局变量，表示数的范围</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">16</span>;  <span class="hljs-comment">// 确定数组容量</span><br><span class="hljs-keyword">int</span> st[N];  <span class="hljs-comment">// 状态判断数组，指数型枚举问题的关键在于确定某个数存在与否所以我们只需用一个状态判别数组对数的状态进行确定，第i个数即对应数i</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span>  <span class="hljs-comment">// 深度优先搜索，u表示当前需要确定的数的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)  <span class="hljs-comment">// 底层判别（即当前位置已经越界）</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,  i);  <span class="hljs-comment">// 如果枚举已经到了尽头，我们就将所有存在的数依次输出</span><br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// 代表换行</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果枚举没到尽头，对当前叶子层进行分类讨论</span><br>    st[u] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 若当前位置对应数存在</span><br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 进入u+1层判别</span><br>    st[u] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 恢复现场, 这也体现了枚举的关键——“彼此独立，组成完整”。</span><br>    <br>    st[u] = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 若当前位置对应数不存在</span><br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>    st[u] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 从第1个位置数开始确定</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="二-递归实现排列型枚举"><a href="#二-递归实现排列型枚举" class="headerlink" title="二. 递归实现排列型枚举"></a>二. 递归实现排列型枚举</h2><blockquote><p>把 1∼n 这 n个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 n。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 1 个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤ n≤ 9</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">3<br></code></pre></div></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></blockquote><p>相比指数型枚举，排列型枚举有了顺序的要求，对位置的讨论便成了关键。由此我使用两个数组作为主要操作工具，分别记录每种方案的排序方式和已经使用过的数。整体代码逻辑并没有太大变化——即每一层的操作+结果操作。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">int</span> n, way[N], st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, way[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// 相当于回车</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])  <span class="hljs-comment">// 从小到大遍历，如果该数没有被用过，则纳入该层讨论范围</span><br>        &#123;<br>            st[i] = <span class="hljs-number">1</span>;<br>            way[u] = i;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            st[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="三-递归实现组合型枚举"><a href="#三-递归实现组合型枚举" class="headerlink" title="三. 递归实现组合型枚举"></a>三. 递归实现组合型枚举</h2><blockquote><p>从 1∼n这 n个整数中随机选出 m 个，输出所有可能的选择方案。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>两个整数 n,m 在同一行用空格隔开。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 11 个。</p><p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 <code>1 3 5 7</code> 排在 <code>1 3 6 8</code> 前面）。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>n&gt;0 ,<br>0≤m≤n ,<br>n+(n−m)≤25</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <br></code></pre></div></td></tr></table></figure></blockquote><p>组合型枚举的关键在于组合的种类，不能存在重复。实现的主要工具为一个状态判断数组。</p><p>由于每一层可选的数有不同的变化，所以需要添加一个参数start来确定计数起点。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> m, n;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">int</span> way[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, way[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(m + start - u &lt;= n)  <span class="hljs-comment">// 剪枝操作，去掉无效分支</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt;= n; i++)<br>        &#123;<br>            way[u] = i;<br>            <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>, u+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solving note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破局者</title>
    <link href="/2022/01/19/advice/%E7%A0%B4%E5%B1%80%E8%80%85/"/>
    <url>/2022/01/19/advice/%E7%A0%B4%E5%B1%80%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h1 id="马云说哪种人最值得重用？朽木者、敷衍者、守成者、破局者…"><a href="#马云说哪种人最值得重用？朽木者、敷衍者、守成者、破局者…" class="headerlink" title="马云说哪种人最值得重用？朽木者、敷衍者、守成者、破局者…"></a>马云说哪种人最值得重用？朽木者、敷衍者、守成者、破局者…</h1><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180511/104469ac807e4be1839a5942bea0e0ce.jpg" alt="img"></p><p>用正确的态度、激情和热忱去创造，用破局者的思维模式掌控自己一个势不可挡的人生完全在你的掌控之内，没有任何人能阻拦你成为那样的人！</p><p><strong>朽木者</strong></p><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180511/40f7ffb6613b4457bc3bf922930f0424.jpg" alt="img"></p><p>朽木者分为以下两种类型：</p><p><strong>1、绩效不达标的朽木者</strong></p><p><strong>“每天少做一点，久而久之，便离自己的目标越来越远。”</strong></p><p>他们可能是不错的人，但他们总是不能完成基本工作，总需要别人替他们分担工作量、收拾烂摊子，或者跟在他们后面疯狂地东跑西颠以控制他们造成的绩效损失。</p><p>他们没有承担任何有意义的工作，也没有取得任何有意义的成就，却影响了士气、动力、品牌、绩效、公司诚信度和个人信誉。更坏的情况是，他们所造成的代价不能一次性弥补，甚至最终会令公司陷入困境。</p><p><strong>2、破坏型优绩者也属于朽木者</strong></p><p><strong>破坏型优绩者业绩不错，甚至可能是最优绩效者，但却破坏了企业价值观，削弱企业文化。</strong></p><p>在2017年湖畔大学的开学典礼上，马云在讲话中谈到企业用人观时，分享了被阿里唯一开除的创始人的案例。</p><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180511/f6244ececd354a5fa1d2cc6763068bab.jpg" alt="img"></p><p>阿里巴巴的18位创始人，其中有个是马云从硅谷带回阿里的，他还是18个创始人中，官最大的，做到了副总裁。但是这个创始人有个毛病，马云讲：“他总是喜欢叽叽歪歪，从不做事，就喜欢叽叽歪歪，但是他永远不做决定”。</p><p>这位创始人是明显的破坏型绩优者，聪明、技术棒、见识广，能创造价值。对于这类朽木者，领导者可能会容忍，不忍心开除，但他们展现出的品质，对企业文化、信誉和品牌的破坏是不可估量的。</p><p><strong>这里给朽木者的一个警醒是——如果你懒惰、自私或者堕落，你会在奋斗过程中，不断挥霍或浪费你的才智，并且一步步走向失败。</strong></p><p><strong>敷衍者</strong></p><p><strong>敷衍者是工作中最大众的那群人。</strong>绩效刚刚及格，做得刚好过关，刚够拿那份工资，刚够不被解聘，但敷衍者只是比朽木者强那么一点，没什么光荣的。</p><p>实际上，他们也不够引人注目，只是做最基本的工作，最后一分钟进办公室，最早离开，凑合应付岗位要求，只有上级在的时候才努力表现。</p><p>阿里巴巴集团首席人力官，童文红，为什么能从够从一个前台，一步一步逆袭为阿里资深高级副总裁？仅仅是因为进对了公司，跟对了领导吗？<strong>更重要的是，她从来都不是一个满足于做好基本工作的敷衍者！</strong></p><p>在前台工作时，童文红除了完成自身工作外，她会把沪杭之间铁路车次时间表发给常去上海出差的同事，夏天到了主动安排咖啡吧进一些冷饮，帮一直打电话找客服的客户解答一些基本疑问等等，给同事们都留下了非常好的印象。凭借在平凡的岗位上做出不平凡的业绩，童文红晋升为行政部主管。</p><p>在行政部的几年里，她依然抱着一件事做到极致的态度。装修创业大厦时，毫无经验的童文红边干边学，毫不为巨大的贿赂利益所惑，严把项目进度和质量，所有浑水摸鱼的都被揪了出来。</p><p>非典时期时，童文红除了负责和领导沟通、和保安联络、紧急疏散设备安装，还要负责安慰处理部门里发烧的人，每天睡觉的时间都没有。</p><p>接受采访时，她将这种做法形容为“又傻又天真，又猛又持久”，阿里巴巴的人是，她也是！正是这种又傻又天真，不做敷衍者的态度，让她在阿里缔造了一个从月薪500前台，到身家过亿女总裁的神话。</p><p>对手头的工作很熟练，却没有成长，停滞不前，那先好好七省自身：</p><p>1、在得过且过的状态下，你是不是特别善于发现问题而不是提供解决方案？你对现状没有任何贡献，你只是“守住要塞”。</p><p>2、你是不是通常墨守成规，不能帮助和提升团队成员？</p><p>3、在得过且过的状态中，你是不是不会主动也不会冒险？取而代之的是拧巴、对抗、挖坑、维护旧则、老一套和感情用事。</p><p>4、当你在得过且过的状态中时，你是不是会降低对自己的要求？</p><p>5、当你在得过且过的状态中时，是不是人人都知道你是消极应对工作的人？</p><p>6、当你在得过且过的状态中时，你是不是不会认真地准备，也不会想去提升自己的技能、思维方式和团队？</p><p>7、当你在得过且过的状态中时，你是不是不会寻求改进的建议？</p><p>如果这些问题能让你有所觉悟，如果你因为工作、生活毫无起色而焦虑不安，请一定正视上面这些问题。</p><p><strong>守成者</strong></p><p>守成者是哪些人？<strong>守成者是那些能创造价值，但一有所成就就沾沾自喜，然后很长时间放空自己的人。</strong>守成者在卓越的表面浮潜，但是从不一猛子扎下去深潜、持续不断地努力。他们也不释放内源性激励的力量，以使自己最终势不可挡。</p><p>守成者，其实已经具备一定的破局者的特质——做正确的事，并且表现出同样的抗压心态，只是在持久性方面和破局者差得很远。</p><p>守成者有哪些明显的特征：</p><p>1、守成者比破局者更加需要外部激励。他们渴望个人荣誉、很多的肯定和奖励，如果没有得到，便会噘嘴和放弃。</p><p>2、守成者更加以“我”为中心，更自私，在团队成员陷入困境时是漠不关心的。</p><p>3、守成者喜欢聚光灯，他追求的是盛大的荣耀（这样也不是说不好，只是这未必是最好的方式），而破局者致力于将事情做到极致。</p><p>看到以上这几个点，很容易又联想到阿里的人才队伍建设，阿里的人事关系也从不是一成不变的。</p><p>像淘宝网蒋凡（85后）这样的80后，在整个阿里的管理团队中占比超过一半，而阿里特色的合伙人制度中，也已经开始出现80后的身影，当时内网有员工调侃，90后可以开始准备了。</p><p>不管是从彭蕾常说的一句话“做老师最大的快乐莫过于青出于蓝而胜于蓝”，还是阿里再熟悉不过领导团队的接力棒交替机制，当事人毫无怨言，首肯心折，我们都可以窥见一二：<strong>即便是站在了互联网巨头的尖端，阿里，自上而下，全都拒绝做一个为已有成绩沾沾自喜的守成者！</strong></p><p><strong>破局者</strong></p><p>破局者不是简单指每天加班到灯火通明，看到凌晨5点的太阳。戴夫·安德森对破局者身上的特质，做了以下8点描述：</p><p><strong>1、破局者不是天生的，是后天努力的</strong></p><p>在解释之前，我们先来做个题，以下这些人有哪个共同特点？</p><p>美团前COO干嘉伟、大众点评前COO吕广渝、赶集网前COO陈国环、去哪儿前COO张强，天使投资人王刚，滴滴CEO程维、同程网CEO吴志祥。</p><p><strong>其实他们背后都有一个共同的身份，来自阿里B2B团队“中国供应商”，也被称为“阿里铁军”，马云眼中最具有“阿里味“的团队。</strong>就是靠着他们，阿里硬撑过了2000年互联网泡沫破灭后的寒冬。</p><p>但是中供系曾属于没多少退路的那一阶层。他们多出生在农村，家境不好，学业也不甚如意。但是这些人都有个共同的特点，<strong>专注加坚持自己的梦想。</strong></p><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20180511/ba3f14de3cea4164be3e73cad4c97296.jpg" alt="img"></p><p>早期中供铁军笔记本</p><p><strong>2、破局者把平常小事做得非常棒，而且一直都特别棒</strong></p><p>他们始终如一地自律、关注细节、持续改进，收获完全可预测的收成，所以他们做出了了不起的成就。</p><p><strong>3、破局者文化适应力强</strong></p><p>在某些情况下，他们或许才干、经验不如另外三类人，但他们持之以恒的态度，不断地为组织贡献价值，已经在他们积极进取的思维模式中落地生根。</p><p><strong>4、破局者更多靠内源性激励，他们会致力于自我提升</strong></p><p>他们的主要目标是比以前最好的自己更好，并乐此不疲。因而他们往往不论做什么都是最棒的。他们的信条是:“昨天已于昨夜结束，今天我要重新证明自己。”</p><p><strong>5、破局者为人谦逊，不炫耀自己，更渴望团队成功</strong></p><p>他们坚信只要不断地成长和追求卓越，并且在团队中当好离合器，就能够调动和带领其他人达到更高的目标和绩效。</p><p>2016年阿里新提名了2个集团合伙人，其中一个是蚂蚁金服平台数据事业群研究员胡喜，他是阿里巴巴与蚂蚁金服“80后”优秀技术领军人物。“简单、真诚、不计较个人利益、充满正能量”，这是团队对其的评价，他也凭借着努力带领团队开启了支付宝基础技术自主研发之路。</p><p><strong>6、破局者拒绝借口</strong></p><p>借口只是朽木者天生的行为，而破局者专注于自己能够掌控的生活和工作，他们会早在不得不冒险之前就采取行动，而不会等到孤注一掷、梦想破灭的时刻。</p><p><strong>7、破局者破局者愿意被指导</strong></p><p>他们不把建设性的批评、指导、修正、挫折或者失误当作失败，而是当作有用的反馈。他们依据反馈来调整自己的行为。</p><p><strong>8、破局者这样回答“多少算够”这个问题:“尽我一切所能。”</strong></p><p>“我所能”超过了常规的工作量。在破局者的世界里，他们尝试所有努力以尽可能获得更好的结果，换句话说，“足够好永远不够好。”他们真正的欢欣，在于知道自己正在为一个伟大目标运用自己，而不是源于独自发光、自私渺小的忧烦躯壳，只知道抱怨世界无法带来快乐。</p><p>记住，没有任何一张出生证上写着“此人势不可挡”，也没有哪张上面写着“此人懒惰”“此人普通”或者“此人悲观”，那些状态是你为自己创造的，源于你的内心，基于你怎样去看待人生。</p><p><strong>用正确的态度、激情和热忱去创造，用破局者的思维模式掌控自己一个势不可挡的人生完全在你的掌控之内，没有任何人能阻拦你成为那样的人！</strong></p><p>转载来源 <a href="https://www.sohu.com/a/231265403_99967247">https://www.sohu.com/a/231265403_99967247</a></p>]]></content>
    
    
    <categories>
      
      <category>advice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>inspiration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySpace</title>
    <link href="/2022/01/10/MySpace/"/>
    <url>/2022/01/10/MySpace/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed80d37d205a6f17764acec9f6aaed9dbf2269fe608a1d1fc1e49c98feeeff58">d4e92a42f1929de57d9067fafb4a6cfce833b140071d1c266a143a16998c33e431d40a40e5462c7d6b2ecaf1dcaf105a5eb3ff9db405e67bc205a5dcfd7917659ffdf43e035946cf28a5709dc8a5cdad4eeda7d4638ca4e9ff885267e0602dda99cf5ff76af876335d0ad66a7ae870a2810782a3be3e13fd3f8224751456702029b2cdb5df6b432942cc3fb25c51e16ca7ff21623d2ce889de8d3fc744310a64e02784d9b65fc14cdb70f9ab729a604b6002727288b1613069221fa469fa16a83781e16ad4f991311a687750f32b1389a954124f273b2976fb29c6a232c405a1f7407ae41bfb642ad1707f4af0cc1797f865b9716e7e1dc2d62e22fbcccc606bb85355712db1185726db6862881dffa00650bc4313761a5ed55457e83acf367a54162c77d881ea0b23b270b6d274eb0859a40c3d8799be9f0a81bb1dcfda918a7c48f6d14d4a933030b52c4a8f1e72cd7d2f3e5d21abc6b464eee71285763209321bb6d875464b10166c42f62edff31937b135754fb20ff5d6b8efd07c1aa7c2eb36ecf3e148b6ad3aa4244e4c8c5145fd2e76fc031f0d58c796f79d3ea04720e8f054a309a5ad293fbc7a3d8e70f50a67f2664733704523881b82eb6d7bbafdc64edbc0222143d155f256d3e9e8a67fe49053bd9ff858319adb3da447bd0c9bc2371051cd544764ac59a64a74b643885a13ea3cd7e1b6ad4412f69eb83dbf1b402549a7f47f964f27b8bf3bc01cff3ec9e233d66819f6d5e882f5b7ecd956a935f3491b1e9658b290a1841e33c05683d0d4e2aa6a3202c61861249672c39b022dd38d85d2dc9e46a0eb55a897b2ec65bce64cd5a7193954cd0a78dbe1d6274df1edb8e9b6f73f6045adcc3169bac2a52d85bde57e47f2dea7fb744d403a78bf78f8f8471015cfb616a9eddaae57fc7af22a754b6900d244514eae90883561f1eaa751f7ee781c3f08fd982c5a54c315ec3d3d47b6c860fb2e9a249f387013aa26ef60019141cc3dccd03f821d170e66abe400b14be418c5a7fc98b98a986b5885be4b29be0620bf31a93781457e9494ae239f7a801662e22e9dd2d9c50753baad06b28787bff780197da7457a282942bcdb1f117acb97ece6e940b8881eed97232bf854ab3293087cde6294147abd0c5c1f010d1fa5e3b327a74c7d14ceb861dd53f664df205adfbffee769213a633bccf53fd35d75617cff2956bb592b99f0b1731eb961345758ad746d68f3595833c633b1c83371b7dc8bccd60b8aa30e3eb0f28fd704b1b17b16a59aec914f7a39a9cb2f7d04cb9fecd1f6fb4da6d4619646d74ada0d4cde5aa7bf28b2d563a051d70a596bfbad363658f3890af0ed95b6233e43f03ba22052eac45832a7578f7a796a10da8c3c23d73915ae42e43503081ed3214ebed38afddf3e229ea33982535b673def6a49367a6cf03da9cba2612da33fb2358a9d429e046f9860be9a748513cee3c8184c283a7be623c435d1e6d5b8b7abd3ce3c42daaf8f6f3d8a17fbfdddb126f7e8e79f03d2c53375ea5cb388adfd6f3984bb2bb0fd60dbdb20a07777c55e1dc3209fda21d4e42d542e321c8a507496b2db6be517b58bf960b14702561fefb33f5e87fd68e430b684570334aaa703c8fdad2640eb2714cd7983798087634b1a993d63aae70524c80f8f5ee9df20fcfda9b3fb4f6bd81d5eec6dbfabb1617f518962731920de764d9189a3267a42a724aab11ea806e3a956746c54d8a7c6024952a74e38c7c8b145b108d362f8a1d1370c3e5a3a69fb15801ead0375ed84438baafb55dc8a076019f6ae9ebfc27c1f40571771052016706cfbe1efb24f6d259fb5d80c4f223ef41077e2291e731586070aad5c67c91e32a44959d822e46e5cd4f1984ce7bf457f3b8f1eb3cb20fc7fa1d26a2e0e8b1a0d37dc240b203faac112966e356eb1afed405526c04d101942da1b9af0dbcb96550556817f6731205f401776df5e2c4964b1acdaddfff146eb7d2ff6514332f3d81c0f348da06b7a9daaf44020301be4097759bfefe71e0585b7add9129e0967ef1412fdc4715af789e0597e441f92c07fd379da438d6fcd3d3b9353b607cf7fa1ed3294bb43395dc800ac4bad56f27e546cbaa3f9fcb3df65c9068afae44b34d9f480409284b3e0f85245d98c03e4f9b6578018c048e6ca308935af93212694efffad5e0747139126a39aa9698b88f1fc58d4bff966fa733d7753a3ad28a4fc9592be16d52af2cf1a47e44bb727220011fc60f7b4dbdf1bea8349b108b64e629120c97ccdbe2039139b29a18f58554a5cfd6e92b4a4f12b21c7a31c2734d0dff1b7a9c7517f8c412cedad0239f517eaa66ce277c67d5d753daaa8461917c42aab91c4a3cc184e2943d3ef02689eccb397c80d83520ac851e16a0f319c34d5b549a2023c6c8eafe7cbf0075ceeb6ec27d4f0cefeef186366f1a6f765c41db11e20244f6ba67a47cce204d16a3e027b9a47f52b4e08463a1463d520a040ce79373c81da8a150abfe8abaf23c67e47a3c84f5da92c1bda502902ae8a681014a62ea9ce894f2ad4d32ed48fdd6b8ed84091801b57192435677ec2a95a127e6a8105ba7b3f8e415a7ab18670ea91b85791b9afe6b5a0cbb7b3000cc8052ad1d39ce0a157c290492442dbac9eb9683eaae12ee1187f785e035d8d6cd4efbbf1d8856d6f291c7c73fed689e10a7e14cffca91633d41e2657d62042abcd7a02192827bde1d12b981f8c5f6da8033bcd3be509b16ffc46cbd54492da3fd96a7f857749d37446c0a4cbb06e3272e5b3bda82ca9b18427f0a82b8913c15b1f1dfbdb75a589df9e4d9c04f47a1887b3a2ed752a8323a74ecf72f1c463a02464b35dce604b9a1b323f02c8f76c3d98d46fec43d45dd581b6b3b67df29156b96bacedd0a2f5795c517ecfefa6d62e78c1681e658b838a2e398f4255c4be288c5f92b8d559a36aa73899d055259c2a5696e351a9a2e77693aaeb1f07ddcd0e1cf13e90e11862f1bfc2e74de9ab7ec31efc0585130dbfaaa36303f15b364d7121c096f350e79f1dbe82721630f91054891c2e3d3d2ef769822192a4997bca3669963ac3721f690cb1c48926ca949177c20b9f0c095560a20e638763cf11e81f02dad61360c9d9a0d6b5901fa671d945d8efcb55d59f57d279ef4273df1eff0f451ba11b663e4646d572b2e714b0a2296c7000ae4f13b0dcbd74b9e937b206c2482b7c092daba25c26aabce727c432fcaee981a211c70518fc3827b141b5a6ccda257000a1d24e1117cefb6575114e8b5ff17b4021f89acfc76c5598b3c95eaa05249538d1a44c8cbaae7034d02c2bd554debfc5f5e0f9c6fbb2a6c2a8e30a7dd223214f886fcde09d26720daf9c4d88fdb8f6aa51483d11eb0d77be45ef549b309e347f625caed3070f61375079ea2cb1c04d0fba6ae6ada23a156ae815db301d23a3662c00ef5ccfb67e9505570065729034d965927e72601f95c2c578d9ed1ad7de2fec4869a8045f64f35b036da8adc8a314adf303f618765c231168caac4f87e84f4e5115e3c4c0986a544fe3a81ece1a8de24ac083367a2c283eb321e72e00c993bff959acae86f2984b3caf258fbb8d97ec50d12a721f0fa1e367e68d6b4c1161a2402996d0ea7392c92d53e7949e81418f2b59718ee47ee591f769008fdafd366dc2e325c1dcf4d1107403588d45a3298a79a6d3102b66a79c9cbef555ca5eab3be838770b161aaf65500a48ee6bb07c07836dd21233088c994eb8cdc33a8e51f6198c970a8ed8b890bb98dc64a397d89de3eabe8b1a9819132d3b3aa8cfab9f412af152865152bfb3ea57de8d95356fef323a5acf1ab117f18436fe06180323014eabd4138003e2ddbe70635d9b1c46adf49c1c0cae3ff32cc267be7e17000946df59c5b186a97e692b055b9a620233ea901cb318c067e4d34341c649664c416fabdefb9a5ad3a7a791114f984149d72bef7c598b622b301c2146e647455d3553382e38db8ccb1eab5f2b4766a5ea6fbd163aaa15832c5c3d6236c30c1e7f1f600b371969bd9db14dadf7bda437ef44c8699276b1f12e5d21136ed346eebdf9fbcf9ce8f3c3173e704eaa30cf7eafbac3c504d591126e4f730b5d6a556fdc0bf17dfbe7d18ccfdc4e03b4c7060948c9a75a1cac86c93167032a5dcf2166dbd9f7caac069bad5ba1d5adc6e1332f71de9bb7a2c4923b4698e0fedd19cbe006d05a3cf609a8606a3ae9ba43bf4d939394844c0cf893455c4e69babbed9a4966de551130839d9bc4249afa7c16d4007e44cc6ba1afef9ff582f4f11ede25f00dc62aad816e6f46e8b1c46bfb32eec78f5293357090ec310c827c3b8ffafb2d8e92cee959fc369f01ce486f58a87c84df128b635afcc61a3f7ace519e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">不好意思这个文档不对外开放哦</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>my own space</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid优化方法</title>
    <link href="/2022/01/10/guide/about_hexo/Fluid%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/10/guide/about_hexo/Fluid%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://hexo.fluid-dev.com/docs/guide/#mermaid-%E6%B5%81%E7%A8%8B%E5%9B%BE">Fluid的官方手册</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/front-matter">关于Front matter的一些设置</a></p></li><li><p><a href="https://hexo.fluid-dev.com/">Fluid官方博客</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>guide</category>
      
      <category>about_hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“有些鸟儿是注定不会被关在牢笼里的”——《肖申克的救赎》观影记</title>
    <link href="/2022/01/09/essay/movie/%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E%E8%A7%82%E5%BD%B1%E6%84%9F%E5%8F%97/"/>
    <url>/2022/01/09/essay/movie/%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E%E8%A7%82%E5%BD%B1%E6%84%9F%E5%8F%97/</url>
    
    <content type="html"><![CDATA[<h2 id="纲要"><a href="#纲要" class="headerlink" title="纲要"></a>纲要</h2><p>本文由以下两部分组成</p><blockquote><p>启迪：自我、决心与智慧<br>电影：拍摄手法，绝妙的对比，前后与左右</p></blockquote><p>以及更进一步的</p><blockquote><ol><li>隐忍的前提是决心，安迪有获得自由的决心，他不向现实低头<br>“成大事者，能忍常人所不能忍”</li><li>说到做到的前提，是决心与智慧</li><li>不受制于体制的前提是自我的独立，不随波逐流，有自己的判断，而有判断的前提是知识与智慧</li></ol></blockquote><p>这三点都蕴含于前面三点启迪，就不再过多赘述啦。</p><p>这片文章主要想谈三个主要的内核——<strong>自我，智慧与决心</strong>。</p><h2 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h2><p>安迪独立于世，不受制于体制（体制也是这部影片的关键线索）。<br>他有丰富的精神世界，监狱关得住他的肉体，却关不住他的精神。<br>他有自己的小爱好，石子雕刻与音乐，音乐与创造都是他的最爱，也是他找寻自由的方法，<strong>一个人若有所爱，便不孤独</strong>。<br>他有匠人一般的精神与耐心。安迪可以把几块石子组合成一片精美的棋盘，也可以将给自己雕几块儿艺术收藏品。这也是他能成功越狱的缘由——计划得天衣无缝，<strong>就像匠人一样打磨自己作品</strong>。</p><h2 id="智慧"><a href="#智慧" class="headerlink" title="智慧"></a>智慧</h2><p>在看人方面，电影初期安迪沉默不言的缘由应该是在观察，他只跟有价值的人做交易，他<strong>懂人心</strong>。</p><p>在接受与服从方面，安迪坚信不公正的势必会收到制裁，他接受姐妹花的挑衅，选择反抗，不管结果如何都不低下自己的头，最终姐妹花也收到自己应有的报应。这一点上其实有象棋的影子，安迪在电影中谈及，<strong>象棋是规则与公正的象征，是王者的游戏</strong>。这表明他坚信正义。</p><p>安迪懂得反抗之道，他明白，遇到不公正的对待要有反抗的意识，但反抗之前需三思，<strong>有的反抗是悄无声息的</strong>，安迪对待“姐妹花”与典狱长态度上的差别就是很好的例证。</p><p>发挥自己的一技之长，创造性开拓，这也为安迪博得了非常多的人心，例如身边的朋友、执法官、典狱长等人。人都有趋利的向性，安迪用智慧为他们带来好处，自然而然就将权力与人心把控在自己的手里。换句话说，<strong>安迪在用智慧造势，开拓更多的可能性</strong>。</p><p><strong>阅读是打开智慧的钥匙</strong>，在担任图书管理助手的那段时间，安迪展现出了他非凡的阅读量，这是比较明显的说明。其实在与典狱长交流圣经的那个片段也可以看出其中的暗示。安迪的谈吐与见识也都是因此而与众不同的。</p><p>安迪<strong>善于变通</strong>，在发现自己的爱徒被典狱长谋杀后毅然决然选择越狱，选择揭发典狱长的一切恶行，而没有一味着为典狱长卖命。你可以命令我帮你做事，但不能侮辱我的人格与尊严，“士可杀不可辱”。<br>（这里有个问题，是典狱长的无理举动促使安迪越狱还是安迪入狱时就打好了算盘呢？当然这里没有准确的答案）。</p><h2 id="决心"><a href="#决心" class="headerlink" title="决心"></a>决心</h2><p>安迪说到做到，敢想敢做，用行动与耐心履行着自己的诺言。这和他的智慧与阅历脱不开关系。<br>他征服的了地理，征服的了压力与时间，计算监狱的内部构造，将越狱的每一步都规划得天衣无缝。<strong>整整20年，他没有忘怀</strong>。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>当然，安迪也有缺点，<br>“他就像一本关上的书，总是在抱怨”~”maybe bad husband”。<br>毕竟，<strong>人无完人</strong>*。</p><p>在电影手法上，本片将对比运用得淋漓尽致。<br><strong>体制化</strong>是贯穿本片时钟的主题。<br>安迪、瑞德、老布。<br>未被体制化人物、正被体制化人物、已被体制化人物。<br>监狱与外界分割，外界千变万化，而监狱里始终如一。<br>习惯的作用是可怕的，它让人沉沦。<br>老布受制于此，终其一生。<br>瑞德也迫害于此，好在被安迪拉回来。<br>安迪用行动激励着瑞德摆脱体制化<br>其实影片当中对体制化的内涵已有比较清晰的界定，借瑞德之口道尽天机。<br>三个人命运的参差就是对我们最好的告诫。<br>除此之外，影片开头的瑞德、中间的瑞德和片尾的瑞德也形成了比较好的对比<br>从开头未经审视的客套话到最后自己的真心话——“I don’t care”。<br>过去的自己早已不复存在，时间匆匆流逝，改过自新也成罔谈。<br>我只有今天，我要珍惜当下。</p><p>阳光洒肩头，仿若自由人。<br><strong>你知道，有些鸟儿是注定不会被关在牢笼里的，它们的每一片羽毛都闪耀着自由的光辉。</strong></p><h2 id="影记总结"><a href="#影记总结" class="headerlink" title="影记总结"></a>影记总结</h2><p>从一段故事中提取出关键点是打开思绪的钥匙。<br>就像水库打开几个水闸，让细水长流。</p><p>期待下一次的作品。</p>]]></content>
    
    
    <categories>
      
      <category>essay</category>
      
      <category>movie</category>
      
    </categories>
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>top1%</title>
    <link href="/2022/01/09/advice/top1/"/>
    <url>/2022/01/09/advice/top1/</url>
    
    <content type="html"><![CDATA[<h1 id="如何才能在所从事的领域出类拔萃？"><a href="#如何才能在所从事的领域出类拔萃？" class="headerlink" title="如何才能在所从事的领域出类拔萃？"></a>如何才能在所从事的领域出类拔萃？</h1><p>文章转自：</p><p><a href="javascript:void(0);">红与绿</a> <em>2022-01-06 17:45</em></p><p><strong>-红与绿，让投资多姿多彩-</strong></p><p><strong>红与绿导读：</strong></p><p>不需要很长时间，你就可以凭你的爱好生存了。这需要你辛苦工作、做出牺牲、持之以恒<strong>。然而，让你生存下来的法则不会让你迈向巅峰。打破规矩，相信直觉，你才能成为顶尖。你将决定自己的工作质量和影响力如何。你可以成为世界顶尖，而这一切都始于思想的升华。你真的想跻身前1％吗？</strong></p><p>作者：Benjamin P. Hardy</p><p>来源：期惑讲堂</p><p>有时你会觉得，自己永远实现不了自己的梦想。你知道你想做什么，但有无数的障碍在你的眼前。<strong>你要在和成千上万人的竞争中胜出，才能真正做你想做的事。</strong></p><p><strong>你要如何摆脱这种激</strong>烈竞争？你的进步速度要有多快，才不会让你的梦想被社会“现实”砸得粉碎？你如何才能实现所需的飞跃，从千万人当中脱颖而出？</p><p>你首先要维持生计、更有很多其他责任。你每天能用的时间有限。下班后你还要处理生活琐事，很容易就把事情拖明天了。即使你的心里有工作的热情，你可能也会因为违背了自己对自己的承诺而感到内疚。</p><p>这是一种压倒性的绝望。我们要学习的东西太多。我们太容易质疑自己的能力。也许我们应该放弃奋斗、就这样接受现实算了？</p><p>真相如何？</p><p>赢得大多数的竞争并不困难，因为你的竞争对手们也正面临和你一样的各种实际的挑战。他们的生活和你一样，并不是为了发挥最大的创意潜力而生的。尽管他们是你成功路上的主要障碍，但大多数人在他们真正开始之前就已经退出了——他们只是一直维持着平庸的生活而已。</p><p><strong>只需要少数几步，你就能实现自我的快速提升，瞬间跻身你所在领域的前5-10％。这之后从前5%到前1%的过程，才是真正的难关。</strong>跻身领域内5-10％只需要你改变生活方式，进入前1％则需要你自己实现翻天覆地的变化。</p><p>这篇文章将着重介绍如何让你快速进入所属领域的前5-10％，帮助你铺平走向世界最顶尖的开始道路。</p><p>本文的第一阶段将帮助你跻身特定领域的前5-10％。一旦你达到这个水平，你就能通过这一领域的技能维持生活。正如保罗·格雷厄姆所说，“一旦你实现盈利，不管净收入多少，你未来的发展前景都将变得无限宽广。”保罗·格雷厄姆将这一最基础的盈利称作“拉面盈利”，这意味着初创企业（或者各行各业的努力人士）的收入，足以支付创始人的生活费用。</p><p>实现“拉面盈利”意味着你可以将你所有的“工作”时间献给这一领域，而无需下班之后挣扎着熬夜挤压时间。你能自己养活自己、吃得上热乎乎的沙县小吃。等到了这个阶段，真正实现自己理想、迈向世界顶尖的第二阶段就开始了。</p><p><strong>第一阶段：“拉面盈利”（实现可持续盈利）</strong></p><p><strong>1、从业余人士开始</strong></p><p>Kenzie和Harris最近结婚了。他们都从杨百翰大学中途辍学，开始在盐湖城市中心的苹果专卖店工作。与此同时，他们开始录制音乐专辑，并在YouTube和Vine上发布。</p><p>他们有足够的储蓄资金维持未来一年的生活，所以他们从苹果专卖店辞职，专职从事音乐工作。每天他们都会在Vine上发视频，但几个月过去，点击量并无起色，只收获了小几千个粉丝。</p><p>然后一切都改变了。某天他们发布了一条Vine视频，突然就火了。第二天，一些顶级Vine创作者就来联系他们，随之而来的还有经纪合同的邀约。他们就此实现了“沙县盈利”，有了极佳的展示渠道，在他们成为音乐家的惊世之路上走出了关键一步。</p><p>如果Kenzie和Harris没有开始业余创作活动，他们就不会取得这样的突破。他们有一些原始的天分，但更重要的是他们愿意持续展现自己的天分。量变引发质变，他们最终做出了人们喜欢的东西。</p><p><strong>很少有人愿意从籍籍无名的业余爱好者开始做起。</strong>他们打着完美主义的旗号，在想做的事情面前极尽拖延之能事。你一定认识这种常年一直嘴上说要干一番大事业，却从来没开始做的人。然而，他们在内心深处会害怕，害怕别人怎么看待他们。</p><p>他们陷入了思考引发的瘫痪：内心算计的太多，却从未行动起来。他们不是以自己的方式做事，而是希望按照他们认为受欢迎的人的方法做事。但那只是模仿已经流行起来的人而已。</p><p><strong>2、获得指导或自己学习</strong></p><p>认真对待你的梦想。别把这当成一句废话，因为大多数人真的做不到。你要非常认真的正视梦想，才能超越平凡、一鸣惊人。因此，你需要获得指导或自己学习。</p><p><strong>子曰：“三人行，必有我师。”</strong></p><p>两年的海外派遣结束之后，我总是渴望成为一名作家。然而，直到我的认真让我找到了一名导师，我才让梦想开始逐渐变为现实。</p><p>改变了我写作方式的是两位导师。一位是一名年轻的教授，但他在三个月内教给我的东西，比我过去四年里学到的都要多。</p><p>实际上，他在三个月里把大多数人在博士期间学习的整套学术写作和研究的方法都教给了我，在他的帮助下，我很轻松地就被理想的研究生院录取了。</p><p>我开始写博客是在大约21个月前。在我意识到我要认真写博客之后，我决定寻求专业指导。然而这一次，我选择了虚拟在线课程。</p><p>在一个月的课程中，我随堂创作的一篇博客文章收获了超过五百万次阅读，并被翻译成多种语言。这一在线课程并非我取得成功的唯一原因，但他帮助我取得了明显的进步。</p><p>当你遇上合适的老师教你知识的时候，你就可以进入下一个阶段了。</p><p><strong>3、甩脱其他人依赖的繁文缛节</strong></p><p>流行的才是错的。大多数人都是因为平凡的原因才行动的。他们遵循的是无法让人发挥最佳潜能的繁文缛节。他们的路崎岖不平，这样才能让所有人速度一致。</p><p><strong>当其他人向左走的时候，你就该向右走了。</strong>美国作家达伦·哈迪曾说，如果你想从人群中脱颖而出，你就应该“向着别人远离的方向前进”。</p><p>正如美国企业家彼得·戴曼迪斯所说：“在突破性的创意诞生之前，人们只会把它当成疯子似的想法。”如果你所做的事情在你自己看来并不疯狂、但其他人却觉得你疯了，你可能已经走在了安全的路上了。</p><p>不要遵循社会设定的规则，而要创建自己的规则。重新设定游戏规则，你赢起来就会分外轻松。忽视骂声、惯例和习惯的事情，从心所欲、贯彻自我，鼓励、相信并且行动吧。只有确立一种贯彻真我生活方式，你才会快乐。如果你忠于自己的心，你最终将会迎来美好的转变。</p><p><strong>4、在成功之前，坚持再坚持</strong></p><p>耐心。</p><p>如果你还能接着干下去，那就干。<strong>坚持不懈是让你蜕变的最基本的美德。</strong>几乎每个人都能短时间冲刺努力一下，但大多数人很快就会挺不住，随后选择退出。一切有意义的生活都会是一场马拉松，它考验的是你的坚持和意志。</p><p>如果你做的是你喜欢做的事，你会不顾一切的完成它。事实上，阻碍你实现梦想的，是你对特定结果的痴迷。你将会为了特定的结果而强迫工作。</p><p>名为“复合效应”的自然规律显示，如果你能坚持投资少量资金，最终获得的复利将成指数级增长。对于好习惯和坏习惯来说，也是这样。如果你坚持的时间足够长，“复合效应”就会生效，你就能够体会到指数增长带来的结果。</p><p>如果你想自甘堕落，你会想尽办法堕落下去。但如果你不想，你就不会。你会减少用在社交和爱好上的时间、放弃睡眠、搞大创意、敢于冒险、寻找导师、获得教育、虚心若愚。当你认真对待你的工作时，你就会惊讶的发现：原来实现“沙县盈利”这么简单。</p><p><strong>第二阶段：在从事的领域成为世界顶尖</strong></p><p>屈服于诱惑的人不知道它的力量，抵抗它的人才懂。经验就是关键。只有正确和持续的应用知识，它才能成为你的智慧。因此，不要做旁观者，而是要直接从实践者那里学到经验。如果你觉得和某人交换工作是亏的，就不要向他请教关于工作的事。</p><p>遵循其他人教给你的原则，你可以跻身所在领域的前5-10％。但是某些时候，为了在从事的领域成为世界顶尖，你要忘掉这些事情。<strong>你要成为创新者、成为先驱者、成为艺术家。</strong></p><p>为了迈进前1％，你会像在半空中走钢丝一样，经历一段失败概率很高的日子。这时候，你以前学到的以前东西都会站到你想做的事的对立面——但你的直觉会变得更加敏锐。</p><p><strong>5、要想表现得越来越好，你必须改变生活习惯</strong></p><p>称为世界上最好的人之一，需要你全身心投入你的事业。你做的一切都很重要。<strong>无论是你吃的东西、从事的活动、花时间交往的人、还是你度过每一小时的方式，你生活中的每一刻要么将促进你实现梦想，要么就正设下障碍。</strong></p><p>大多数人的生活是以反应外在信息为中心的。他们早上做的第一件事，是检查他们的电子邮件或社交媒体。他们有时会去读一本好书，但所有这些东西终究都是知识层面上的输入，而且会让人上瘾。</p><p>为了成为顶尖人才，你必须发掘你潜意识中的财富，努力输出。当你睡觉、社交或参与其他工作以外的活动时，你的潜意识都在思考和研究你想解决的问题。</p><p>因此，你每天醒来的第一件事应该是输出。你可以通过写日记的形式，捕获你在潜意识在睡梦中完成的所有工作。</p><p>或者马上起床、继续正在做的工作。当你开完会或完成任何形式的活动之后，不要重新回到读电子邮件的输入状态中去，直接继续输出、继续工作，这样方能最大限度激发你的潜意识。智力源泉将因此得以涌流。</p><p>保持健康、没有病痛也是提高创造力的关键。美国作家斯蒂芬·奥扎尼克在他的新书《剧痛的干扰》中写道：</p><p>“疼痛和其他慢性症状，是身体内部问题没有解决的物理表现。病症表现是人类身体保护自己的本能机制。疼痛是身体向大脑发出的信号，但我们的本我占据了大脑，把身体发来的信号藏在了潜意识里，让我们自己意识不到。</p><p>在上世纪90年代，神经科学家坎蒂丝·珀特博士发现，通过神经肽传递的潜意识不是运行在大脑中，而是通过整个身体运行。这意味着，我们人类是生而一体的，大脑是与身体一致工作的。</p><p>我们生活中未能化解的紧张态势，将最终以身体疾病的方式表现出来。当我们意识到自己存在这种紧张的时候，我们才能让身体自然和有机地痊愈。毕竟，健康的身体更容易带来灵感。</p><p><strong>6、给自己一点休养的时间</strong></p><p>少即是多。</p><p>当你并非庸庸碌碌、而是高度关注结果时，你的工作开关会是100％打开的。而当你不工作时，这个开关就是100％关闭。这不仅能让你工作时表现完美，还能保证你充分利用休息和恢复的时间。</p><p>科学证据可以证明这一点。<strong>工作与休息间的心理分离，对于高效工作而言至关重要的！</strong>工作与休息间的心理分离还会带来其他好处：</p><p>如果你不能该休息时彻底休息，你工作的时候更可能拖延和疲劳；</p><p>显而易见，如果你做不到工作与休息间的心理分离，你的婚姻生活也不太会幸福。</p><p>高强度的工作就像健身。如果你在每一组练习之间都不休息休息，你实际上就练不到你肌肉的爆发力和耐力。然而不是所有的“休息”都能让人恢复，某些特定的休息更能放松身心。</p><p>我恢复身心的方式通常包括写日记、听音乐、花时间陪伴妻子和孩子、做饭吃饭、或者服务社会。这些事都能使我振作，让我不仅能重回工作，还能工作得更有意义。</p><p><strong>7、设定一套“表演前流程，方便你进入状态</strong></p><p>约书亚·维茨金是学习和人类最佳表现领域的天才。他是国际象棋神童、赢得了五座巴西全国太极拳竞赛冠军奖杯、如今则正努力成为巴西柔术的世界级选手。他自下而上应用了许多学习的基本原则，并在许多不同的学科对其加以应用。</p><p>为了进入状态，维茨金建议我们设定一套“表演前流程”，帮助我们减少压力和焦虑、让你能顺利登台亮相。这一套流程通常需要20-60分钟让你进入状态，然而约书亚建议在每一次登台前逐步缩短这一套流程的时间，最终达到轻轻一点就能进入状态的目标。</p><p><strong>“表演前流程”为的是改变你的情绪状态。</strong>大多数人在开始写作等等工作之前，会经历一些情绪上的阻碍。恐惧，不确定性和不适感等消极情绪都可能成为阻碍，对你的表现施加负面影响。</p><p>“表演前流程”将帮助你变得心平气和、充满勇气和力量。这种情绪状态下，你工作的成果将远胜以往。你在工作的时候感觉如何，将决定你做到多好。</p><p><strong>8、拥抱恐惧和痛苦</strong></p><p>“英雄和懦夫内心的感觉相同。但懦夫逃跑的时候，英雄会利用他的恐惧、反推到他的对手身上。<strong>面对恐惧时，感触人人相同，但重要的是面对它时的反应。”——库斯·达马托</strong></p><p>让人无所畏惧的观念其实是错误的，但却经常被强加于人。真正的表演家也会感到恐惧和经历痛苦。然而，他们学会了像练习瑜伽时一样，承受并转化这些痛苦。</p><p>自行车是一项很考验意志的运动。正如泰勒·汉密尔顿所说：“当我全力以赴时，我发现我的全部能量都被用来执行一项激烈的、不可能完成的任务。我的心咚咚的跳、乳酸在肌肉中丝丝游走，但我却能感觉良好、正常、安稳。</p><p>骑自行车者经常提到“痛穴”，指的是他们在竞争中越陷越深的心理状态。“我陷得比我想象中要深。”“我到极限了。”“我撞墙了（指成绩到达一定水平之后完全无法加力提高）。”在骑自行车比赛后，你会经常在采访中听到这样的话。</p><p>“心理弹性可以说是成为世界级表演者所需要的最关键的特质，应该不断地得到培养。对于我自己而言，我一直在寻找让自己越来越能坚持下去的方法。当我感到不舒服时，我的直觉不会让我避免它，而是要学会与它和平共处。”——约书亚·维茨金</p><p>你开始感觉不舒服的时候，正是你逐渐变的感觉良好的起点。这就是你成长的起点。一分耕耘一分收获。这会让你收获快乐。大多数人在这里放弃了，但你不会。</p><p><strong>9、因为热爱</strong></p><p>最后，最重要的是与人性紧密连接在一起。<strong>你对其他人的爱，会让人生中其他任何事都黯然失色。</strong></p><p>以上这些训练和个人进步的内容，都是侧重于自我反省和提升的。然而，注重外在意义、关注他人的需要，将为我们的工作提供新的意义。在从事的领域成为世界顶尖，不是为了你的生前身后名，而是为了那些你热爱的生命。</p><p>心理学中，动机分为四个层次。</p><p>在第一阶段，人是被恐惧所激励的。你所做的一切都是为了避免惩罚或消极结果。决策理论认为，这种形式的动机关注的是“预防”。</p><p>在第二阶段，人是被潜在奖励所激励的。你做的一切都是为了得到你想要的回报。如果你信仰宗教，你遵守的会是教义当中提供祝福的诫命。如果你在商界打拼，那你只会做那些有利可图的事。这一阶段，你关注的是“提升”。</p><p>第一阶段和第二阶段表现出的都是外在动机，这远远不如内在动机强大。</p><p>在第三阶段，人是被职责所激励的。无论有无外在奖励，你都会做你认为你应该做的事。你不再害怕惩罚，因为你的动机是完全内生的。但这一阶段缺乏的是激情，缺乏的是一种能让你超越人类的能力和理性的动机。</p><p>在第四阶段，人是被爱所激励的。你已经不再担心自己的需求。你的目标是为每个人带来尽可能多的快乐。你的爱超越了人类的理性。大多数人会认为你做的事都“疯了”。你的生活不再依存于传统的规则，而是受到最高尚、最纯洁的力量引导。</p><p><strong>结语</strong></p><p><strong>不需要很长时间，你就可以凭你的爱好生存了。这需要你辛苦工作、做出牺牲、持之以恒。然而，让你生存下来的法则不会让你迈向巅峰。打破规矩，相信直觉，你才能成为顶尖。</strong></p><p><strong>你将决定自己的工作质量和影响力如何。你可以成为世界顶尖，而这一切都始于思想的升华。</strong></p><p><strong>你真的想跻身前1％吗？</strong></p>]]></content>
    
    
    <categories>
      
      <category>advice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>inspiration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021岁末回想</title>
    <link href="/2021/12/29/thinking/2021%E5%B2%81%E6%9C%AB%E5%9B%9E%E6%83%B3/"/>
    <url>/2021/12/29/thinking/2021%E5%B2%81%E6%9C%AB%E5%9B%9E%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="812cae57b0f4b435accdf7370a61d0a38a204b25bc70e4ff81c7c864302cec52">6b58125f11c3c6477c25a16b805298db16ab8fad3deb674cc00f9de73ff32fb62eb9e9f5540b11e129b37d9605f6e72e0cfde81b710019c73eb25ff619b09b4f0642a5e807f79bef2b58b598e03ce7ff30a26f5163649464fbbfe51f4455389c6ad6788f5379a5ecbae1428afec12d6a6b9399bb5eca0f9a8b760fb6fdd7efd09db78b502a8a9b20da7a2209b9d13f7045dcc8edb8f20814579c5e2b72f1b1f24e0db7271207ef2daaa2e29a78bc15c2d130d2d1d993deddd9b6a62c56db527111fe25e52529f70974026b4381b5ad88ac9b8e43ba1b7ee532d7200118b9a5add5387bea67fbced853ca1f5e20b7c40ed637697b92528645639637b94145540e7d7c58bd4f15747b88e7bfaf2aff00a6496b4e0c44c83091dfde516a1557ef5edd2b27b22080ad709fdbcfff07fe140d3f883aa5adc70f6a8b7701c63436fa8c7c5fb752d74190973c8ec1cd4611a27f6a0b9b2d4160bf3fe79c1192aa4a7b74a9588644097c9ea05d8a3c05b9eba1ae0ac5655e25777e3fae04e3cef22ab6b40f7213c8ee9240290b73e76d59574b0161df425b10a6a1c6ae1afbc8a775c969c1ff1d14d294082fb6ae75b73c1389b7debebc03a693c035b45ea054621cff5dd2305365ca98e7538392e87cc6167d3c3ab2e532e15567e9dff9b9bfeea0c01677cd276de8e2ea3094ed18fdd25a21c3be9a84ef2e9751954801c4c6d7451a60690d87303bb0d69ad66625d81af0ac595f05937afb6af13412f19202619c571624077e2b5ad6a3a30693a3e70f4dff9d29e30bad976bac3f42e5f4166caeb53511744fe048c3d30826766c4431ead363e0a67dfb64075a2c65a7d70e38a0f2fe595aaf3484d5cc1e34342d168a883c12edd813cd5d371048ade7d01693cab1c962c7d9ba2718c2b77b8665eab04050ef82ed9a5d7a04e62ba9dfe710a3424abbf1ce995db15e763c2a7bb6b1d9d272ec907b96d6491d80075249a2f09690f65b6809309d086a378536326010d3247b1be70444592630335a20a0ee97adcceea1b97e7aaa6f3e6cf259706fd4b932a6ce3ac4bb3a91e5e965dc1996fc8c90d64ff33586d1d02c1f15e990c6bb879f89e889a298417d9fd8955e8744d8092fa7ae702fdd56105478519312233576d08ab7113c57d460ec83ea47bbdfcbd35db674f82876ad77d3885ed3cba6cb3a89bb50c0d066a2eceb652cc789ac7fc3ea9e885f28c9809221d385ada5e3f2b8ab7b0538d542ad80149c9e6fe130ddfb0178d08d12a2f6af7141daed100d868a004e0f19274978dab31681a62b89a5d51b4e0184b92024396453dfc38612d145f55af451b8e7852f80b87c95d328ec0d2aed4ba9ff35cb6a6da35e276bfff6121d1b0b059a8e543ccea6374cc24183bd12245fa233b8179cd35193e76f72ec47ab632a7e48da433d9d9b73811410752cc2ccc68a3bc8c428d569451989a9a67543eae150423208ef6620ab1df992d73314819002408b938bc84b3fa7005a8117cea17ed1d47afeac9455f47260173b71d15b371eab648cc1614b15e4fe7e32ae16c35042ad6e87454f4489da747974e47f40a2653a5a47050c59f2eb8ec2908bb84ad3e8998c0e7ccb4e206318d971659df67f0915210fc1562da3470031b198e75253f3a7be8b30104d5b0b2dc32b22b9ce0b01f8dfd70506b0de9c2d1c636fddb39111545a5d51c859db263a56491a479fb4d61b9dcd7de6ad0393be0fc903a3b65d50896df9019f3edccd02ac140c4271cb4c0012edf7b0ca35b4618e13b478881912749d3b91e7dda5875db424e8336effb83ed4d4aad1036cbaf83ce0f07b004dad4116da7ce708774997697bf0233061490bcb3369607f5877fcdab5b3c384493b29cacde3954f6f9682b8adb8f1470cb0d39b8a8278cc0dfe6a15c0f7a52e6f6f73eb069d284806959e385a5cfd28bff71f19e5d9bf55a00153b23493cb181475a39b56b2969d2385234ce53b9a956f2b889daee5423eedcc0d4470e1af9f66f66191d855c06023107af0b52ce16c139a37cbec3c202c351d00fed758d4dbb0494ca3fc3ec618a433802e98395c0fcac169ac203d8bde003ce66b58f4c96c900aa25a0ac6bec1a48e7467138212fbe7c8c1e3880e22c0d3e33e2e6bcadba4be3afbc0f105b69067893c8de0a9d78b7bf863e27318c220cdb80d9a8547ac14927a26b7d827c5ec84fe6e7d2a9adf9508d11acf3d3c2543eb7eff62689bf160ffbe5068b97e3a55832c8ca3b9c61836c7673386d7aae531bb60b702d46c70f660ec55743ddcedb909c6d8084d296523c0a1ac71f4ca8cc7829b748ca08fd908bf9a49228c6cb44b81e500b2d47f7cd4c7ac1e5ee51be0ad51fac1a1231a5892c6b49aa3f2cfb1f9fb089921e7f25d2c7775842f1a50bcd936fb56fc7a059a8bd2360f34c76bc7e91d78f23ca3fad1b84738699ffe4da1be2b4efd5e9983dd787140c77fb78237ffe4fb53d8df1edb5e1f4568b454a8d332053e58c2b4238ade666fcd9401aa5f18e3219d9d7da591bd5acedf732e5d92a7a859e08ea504b8d57299b17d109955ee71fa8f5018b2f2a0c8fe7e9eae0acaed5bf68cae8e27f41f3d2e728e00e55f6068833fce7a19c6e55f9771532af7ad995434ef205316fc7bbaee61b2683439544e5bd860fa64272d0b1adb2fce9fc4cb3c930fe2cfdb4f51bdebc5a18d45b4d829eda7e6231451f86ac6d7331ab6a555cc4bf8e79a63499ec766630b97f5d84947020653f7d1e3ab2b89628bcde598209a866b85022b680f4a566b65e2e79a8cd512b2f0bbdd2b4f4d976d27f830ddb4570540fae37cc980ca961a90aff7bff3887055971dbfbb455361cef62b8a5262809a13156d92f8cc1fc7aa0a87a62f65f08a287abe8124fbeddce32c2f3657e813a6bc86b8e7175948d746e3b0f8226779c40afe0defe68d8541c56b4d87c837a2e4c304245f009868705fe92ea5189734c10bb08854fe2253efaaef4dfa129a6e57c16505056e4ce66a77ff76e49186f4bda6b5538aa0f0c98f3ece62ff31b6d0e12433e223f0b65e4cb5dbef01b6a35c254acd82c359cf2ea53f2c84b466ee529e70abbf4e3148c38cb9e904ef78d8581c927f8f2f19409c989f87595ed28e66c5207d92d201dc91ef3baa12919bfcc7f7e31e960f17a619aee52b447541ba42132c990d51284917ad45f7742dcd210f69252f5e1f182b245c64527bb51a44e201fe53710854f225543fb29d637462191f66838e9e77d571402ecc0e9df3ad00406cd49339b0819ab685abd457404297d811072595a490c09b674016be87e52afcd78f1955dbcfcf2193125bc248df98635ee133c5d40d929dfb64426439f3d13500faa7a4c71fe823f336fedbe25fd58b19d501058f090fb132e55b24af847e6352d515736f6e4f90d953256e97d7627329109d3eea78c65df24e7ae1e9537b2a5617cc190ea633ac4bade9f2d525e8b3dc9328c16990cdaaa24d04899f68270681b56588b6b4b3ab25279b80470ca8e294d729ab9c7c574e8f61b7a7d6efd4ff9adcff6a902fa0671d670ae79efc9a8a5dbe23c5e08f2305888b62e21b1bdcf96c7c5ee26d0d337dc0c2ba8a039e8c88290f0e2c2b5035fab15df26794a1a7c327e002c1cfb732dd7bcb9928b279125c1a5cf691a10a8efc9779a77778788024c0516a67ddb19a8134fbe196db665981950fbc80e1895dc77ae58ca4f61d700c4c818fc7bb79de092cc574455568ce5d1bd175966a30caf5c8955da2022ef82a3bafc73dfebedc3b9daa740c18c9cb679934df15f8a6fc56d6e42439a40928a763f9ad4b04dfb0544e72fbb4b20af4fb68ceb88293f14b2736b64115f5c6496bfa1c96f2fe63afc6479f7577597e942be520066538a0b6b9df8fe55c6371c67fc59147289fb189aae4b714d9f7c87ef78834dcd21932ac5625c33e9ad28d3884b60c2d61b461b95ecc2378f0b5710afbd23c37fcdd563962dafadb4629ed8adb720bdded249ecb2aea848681e4f9b96f1f1af99ce89f61e2bd982d786aa0545cb6a0f5bb9fcd619f277d55be66640795337b64ca8d3138198452c31f31c0b312aa257b24cb73074d83cfce6404b660c496589a9405dbbbd3ac3279a39466d002ed76679749eba52478b8f05d1700e03f3ab488ce0acb6d692220aa6a990fbce41ac88da497af92a806a6252a221362e4cbd7eabf29d05bd4834e3c26a4adc1011067bb8b4f5b3ea39cd5f6798dbd7aa92dad7f4f266a54871f767cbec9c9050590cd5d86d446d7d04d9fb045d1496fb394487a59bc6387738f42e4487689a2d621edea1ea73de8b2c33dc03723b3d7c52ab7fae4f867b076547300aabc33cda2d061387259010faf69ab81626c3e648dae65b597947c0bf4f5060aa5a9d5ac67f8710c3302bdc505fdeefaf98b470c412b29e627ba1e8cc99824e9d1a6bc0fc2a2a2717ae7e38cdcc43a27dd9323737369b0d6b48f4ed29e2d0e59ab6db0d7844a453ab06e6880434d7b7905acbb776180a99659fa5bb446d2176027c106bb2a44ca79ca2526351f1cf101b289082c47cbb6ffd1d74277eca27ba88b5f421266acaef2573be01436254ea8bb0e930fcc55148cbaf79c7897b6d0dad42a25d7fa63ef28dd708dbaf698b91ba37383b90c6d0cca4691a6d25fa4c8b1290a3f5f59cf0f3025c639761a1f1d00aef8a275323f292e504c60b7b899e7aef84851ff6046de633ac5c2718b02b10bdac3ddf336df6909c08d36ae96d1c08d9bc05acb2ce279ff4ab3451be5d19c2efc98b03dd28ce16ef33ea98a807a039c31cb22a761b2c28e712d7e3cfdc1650db06637c846865efbe887dc874c9d3790fdd2813c4244c63ce696587879003adfe296aa17c476e17b21fad75b325a896f983552deb3bc39fdefc1333f60ebfd9e787b90e5f947213870c3ab93ae4c4499c54fdaed30d4283d24c1cee1db56675be959f78d88e723513d9bf6c37f8e7c97bcbeb8533cd36799bff0ba2ee5cb94fe63481a7c8a3e73f88deced8e0771975eec4b9ad4abc4d2be2fa44343a8f927e715c5c2b8ae856582f8603a2e86573fdef92754f8a6a85f8c72cb03f3702efa6968d751a0dc0ed553b2c29e03c917f4915ea57577b216e81e78c5f21b4eb4c515b096afd3050fdaf0dbe147f9cc51a051fc8fa2c3d88c835806074e7b1231ae89e73ef9f4ff4152b37dda9ef3693fd936a8789070b0e381e8c80383ff733dfa663cb09db554329a454e59ac9b42f19741241766198621b3ca16ee60b90081b2681440b9bb345a14332dce8f088069a1a4a81cfbd1c2cc8980761a82d548641f749b58b901a0897aa42989814a9fd8928c32752beb6d1dea084b2d69be3a357baa39948d1fd2e1afd74ccec985a3e66ff4cf93e475728da23c424b46bbfa7589acd91a4bce6e2d0cef7e817e863b7694ba0419391a2d9fd9b8c0fbdabe43af97be411bb91731126bbf680fa77efd76f6962e8377db1b0d6ab3c31cbff4383f1e483a2ca7dbaf68c4a793eb563da3400958ba6a0b67f9f4322003f7724c21a8d5726334c160261fc16d1888327ecf26120f5ee72b2e77c00404ce224094159eb00446dea4a99a90e388ffb9faeaee5558a70fb1dac11b04600d5e35874701cfe2d8aa53297e1b73fe2d0171f2b3602e916441640e1338d45e737cfadc571839aa9f2c12d9bfd7d65d6a3ea70df480a2d27fb79f71f6bbcfe169e01a06240903df4be94b8b6f3d1d3a216fc1286120186709830ee22d2124aea6dcb9bb17b88f748be25361f644677da0f0bb4e014ec325f2d0000e96a6094158c694449f48e9f8664fa3cbc071784826c3a45ee130d228e66350270410d32e943164a7f3fea65de68940a25a88914c1da1414f28f91237b4a4e603b4431c87af1fcfabe4d1133862854ea80b78b95acae18e093aeaa6afc7e20d95cb705c5237f14bc0e695f1ef8d7127a09445d99f8040723b7749c9fa8bf6f52b6b57ee1ccbf959457361e7f04ca6e1fe94b40ff12bb5f0b48c23fa53381b025cdb8189a61ad16a2e9d870fbd35c69e6dcc1c3245747ba82145cbfc7315dcd9bd5268aa49586e9bd9b46ac999b134539c6c10f4b3539bf61190d51030971e8523ef14be3414592fb51e9c0d203af6cd736097f0020f81e095139859af0c293740fb0b1ba47e41d6ec002ff4588b24ac68996a5505433b755bd4732e90929ae98ce3fed9b750af86bb80a87e97b5ef4ac672c5e47344104b8c63bc49aea6d75518fdb6a1a919c299b19cbee941ad429f45802a5cbedf3b9cca8c20b878de72db8b6aebfe4bc85c5c3c6540a0199137cbef8967896df66f6196fe7580bba2e39870fa56c15809683a6bc46d9113d1c70a39ad235cb18ff83c1ebd86e3e86f6969391e8a1a07543b44cbe907e8c11b4faa339a065eab6ce1ddac2c65d0b4d815c74c173458a74ded3172e9bf96a962e8115dabf9f878a44cd352668db80e15fa7a153fcb4b9da64b4fded3ea27eb98795b9251bb0588d3679489e1d71f61bcace5e83dc0ec03885690336c146f42616defd4e620f5f48d8a2aba35d1750de9a1ddaa575356b849f1b0c9bcd2db22781b52b9ea079eea487bf83e7d0c6b4829942dd3edb36983748d2d1e946d81e7fd9d2364996ec84629e568a97c1e1f40f8f7bb977f845ce54d943a861958fb2ab3e898d1fa8e5a48fbc021bd313f2f311aeb21d2a5d5aca96fa0f9b8d2f324077e42f2570319c7de07e418630082d7f2b596004be93daf0ca3f8b02d062a53385f39ecdd9839632d577106e490775c30040ecba4e18b717e5f79a7a3324dfff78e8396d3513a3508c333a06c00f35e74afc1940887da834d4f39db9f00020a5e11114039d691033a148682eefd6a857afa52f65c0cfca39ce10555ea84f0d2d72269f72dac8378cf4af41cd6b3e608c3551ca1433df16bbd50116bb91b3cb79553205ca63226149f6a41da9d1bf820b3ccb36c574580418023bd2572c018e91dd31e4bcc1f8d685394430b3f7c42c037deb3ecadeb9fb08b35471dbbb480deefd7fb924b04a671910df1615dfebeb270602083d46f85147f7eab9494fed72fb79b71e25271c434d706c7cfae620698614e1688f74bbb7d77295e43a9bb6d4095c6b802224d5ca4b9561f5bf1f9cf15e9b27da318fe7f04c543dd63e02b8a6fb8ea8c08065505c2cd12ad82fb656d1553ec07ab1ca93bdaf861af828801b4a69cbb7de4d8d4ba29af45dddbbed88412f566fb21f3f9fc6b91fc6232de6bfa2cc21c6d6cfcc86931ce93ac9e87d569856e43d6539844b282d7fb2131ef0140ac5a7aac55c31b7994086159f25704c5b6aa6ced8f32c99e2bd8968e087c83b3a68cef647fc86461a360e08de6eb6ca49112a2a10459d578a88a29264a0f3088a8e10f3869068348865b25c9f127e669fe74a499008f2087747ae3f6fb665cd61d0f013a378a014a19ce0083d78b7cab0a3de2e4c57aa25ff686a707af67e37caf186aebbdc041210b0b6e59f2b45fca0d3cb2ec494a643658da200bbb14e7bbc693d92e58cc800c53dc4f708d655c6588487408bb18c566d275132bf9e68dbf8cb94ddb7ff4988be92f636738c68e44d5a4573412dc9e2f5fbd7b901e5c3ab66c37486352529a6d32243b9d50f0dd7d4ddc48a47692fad720f3c87896d229f7253d52effcdc283920b2c1dd73bf1bd070b4ec1458b16c11a8aceab813f40a7cdbb401a7ac86815886540d82a106fe8f6709353370d58c36de697b65d8fedc79b40df8f1f438ba00d9e2e06b3a5c72d93a06a7a209e17e2205ad8292eab11ce0c6ed6d63d226c76ca85ce203ae02051aa4ef107d9ef4b796dd715a7b05704df1909abce7f0265e621efdd9317453357160121c65861a7795fd1519c872bd3de47d05f86df2cddd888afcb36c7e37e4ce8d5dfa9dc810ffc3cb77d1ceffecd82c95d30698b1f8b42735adabcbf29106cd9eba64aa532828fa02fc6d50f0daefc07037ebb1eca985c8af213be62477a92bd4d26b07dae1b16a872fe7ffa21be021a7c340e0452cf6022419b6c4118850c2dd41362020e336a6f8e2dbe8aca9d2c85022597e4c8491449c0d408e1392228b4d757c7ff632c0ce25f179facff042</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">与我的生日有关哦</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>remember</category>
      
    </categories>
    
    
    <tags>
      
      <tag>thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown教程</title>
    <link href="/2021/10/10/guide/manuals/markdown%E6%95%99%E7%A8%8B/"/>
    <url>/2021/10/10/guide/manuals/markdown%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Markdown相关 <a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a> <span id="more"></span></p>]]></content>
    
    
    <categories>
      
      <category>guide</category>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文经验整理</title>
    <link href="/2021/10/10/experience(%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E7%BB%8F%E9%AA%8C)/working%20experience/%E8%AE%BA%E6%96%87%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86/"/>
    <url>/2021/10/10/experience(%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E7%BB%8F%E9%AA%8C)/working%20experience/%E8%AE%BA%E6%96%87%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="论文整理经验"><a href="#论文整理经验" class="headerlink" title="论文整理经验"></a>论文整理经验</h1><p><em><strong>2021.10.1-2021.10.10</strong></em><span id="more"></span></p><blockquote><p>论文不是作文，结构要紧凑，内容要相互关联，承上启下，具有故事性</p></blockquote><h2 id="概要与引言"><a href="#概要与引言" class="headerlink" title="概要与引言"></a>概要与引言</h2><p>概要需要简洁明了地说明一个问题<br>引言要在概要的基础上做扩展与延伸，注意这也是一个讲故事的过程<br>可以对一些外文做一些相关工作的翻译，但一定要注意关联性</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>有一个非常关键的结构<br>。。。很重要<br>但存在。。。的问题<br>对此，我们开展了。。。的工作，在。。。进行了改进<br>整个部分各语意的连接要清晰自然，不要太技术性<br>还是一点，讲究故事性</p><h2 id="具体想法的说明"><a href="#具体想法的说明" class="headerlink" title="具体想法的说明"></a>具体想法的说明</h2><p>清晰明了，有很好的过程性</p><h2 id="引用文献整理"><a href="#引用文献整理" class="headerlink" title="引用文献整理"></a>引用文献整理</h2><p>严格按照目标期刊要求进行调整<br>一定要找到论文的官方文档<br>（经过了很多天的折磨与尝试。。）</p><h2 id="对细节的处理"><a href="#对细节的处理" class="headerlink" title="对细节的处理"></a>对细节的处理</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>研究历史<br>研究目标：一般紧跟实情，提出问题或一些缺陷<br>概括自己的优化方式与优化结果<br>关键词说明</p><h3 id="引言（详细版的摘要）"><a href="#引言（详细版的摘要）" class="headerlink" title="引言（详细版的摘要）"></a>引言（详细版的摘要）</h3><p>在摘要的基础上进一步做解释<br>交待历史进展，一步步接近优化对象<br>指出优化对象的不足之处<br>提出优化方法，条理清晰，绝对细致<br>对概念的叙述要清晰完整，单独介绍，然后融入文章，同时可以联系一些相关商业实际、预测范例与竞赛，并且一些关键的技术可以做一下介绍</p><p>同时概述的技术背景具有很多的相似性，对其进行概念提取并描述尤为重要</p><h3 id="资料渠道要做到实时记录"><a href="#资料渠道要做到实时记录" class="headerlink" title="资料渠道要做到实时记录"></a>资料渠道要做到实时记录</h3><p>个人翻译是个减少重率的好方法</p><h3 id="引用整理"><a href="#引用整理" class="headerlink" title="引用整理"></a>引用整理</h3><p>比赛之类文章通常以文集形式出现<br>比赛之外通常会有press标识<br>文集与个人论文有很高的相似性，注意排版</p>]]></content>
    
    
    <categories>
      
      <category>experience</category>
      
      <category>working experience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>experience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观上大龙门石窟有感</title>
    <link href="/2021/10/06/essay/travel/%E8%A7%82%E4%B8%8A%E5%A4%A7%E9%BE%99%E9%97%A8%E7%9F%B3%E7%AA%9F%E6%9C%89%E6%84%9F/"/>
    <url>/2021/10/06/essay/travel/%E8%A7%82%E4%B8%8A%E5%A4%A7%E9%BE%99%E9%97%A8%E7%9F%B3%E7%AA%9F%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p> 铭心妙相，龙门石窟。<span id="more"></span><br>此言不假，上大虽然只陈列了龙门石窟的单单”一角“展品，但也带给了我极大的震撼。这个震撼是多维度的，不仅在乎展品本身，还有展品内涵以及展览设计所营造的独特氛围。</p><p>走进龙门石窟展厅，看向四周，一个最大的感受就是小而精，这是其它任何文化展馆所不具备的特点。这样的创新使得我们能够用非常少的时间去完整欣赏最具特色的展品，从而快速地领略龙门石窟地独特奥秘。也为我们打开了无限的遐想空间。这种氛围感也在一定程度上更新了我对文化之美的看法，让我更愿意去丰富自己的文化底蕴了。</p><p>在这么多展物之中，我最喜欢的一件展品是石门窟。其中一个原因是它规模之大，构造之精巧，但并不是最主要的原因。3D打印技术的引入才是最令我惊讶的地方。科技与文化相交融，已经能够完美复刻出人类难以想象的至美之物，用”巧夺天工“来形容也不为过。</p><p>每一件展品都在默默无闻地散发着独特的美，这种美源于个性，源于创意。归根结底，它们都诞生于古今艺术家之手，魏晋风度、大唐文化，在这之中，有古老的诠释者，也有新时代的表达者。细节放大、巧用残缺、空间布置种种创作技法在我们的眼前展现，顿时我便有了一种感动。艺术，融入时间的河流，亘古不变，这种静态的美，似乎已经打破时间的限制，让我们有机会与其对话。</p><p>而这一切的缔造者，是科技、是创新、是人类对美的无限追求吧。</p>]]></content>
    
    
    <categories>
      
      <category>travel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络连接问题</title>
    <link href="/2021/09/12/question/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/12/question/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p> 问题解析：在使用github加速器后，qq能连但网连不上 <span id="more"></span></p><p>方法：网络-Internet设置-高级-重置</p>]]></content>
    
    
    <categories>
      
      <category>question</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>军训小结</title>
    <link href="/2021/07/28/essay/feel/%E5%86%9B%E8%AE%AD%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/07/28/essay/feel/%E5%86%9B%E8%AE%AD%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>  两周的军训，转瞬即逝。我觉得这段时光可以分为两个阶段，第一个阶段是“监督学习”，第二个阶段则是“无监督学习”。监督学习阶段指的是连长和副连长对我们严格教导训练我们军事素养的时光，而无监督学习阶段则指的是台风烟花登录的前后。前者是对我们毅力思想的双重磨砺，后者是对前者两个品质的考验。两个阶段，各有各的侧重点，但都颇具价值。<span id="more"></span></p><p>  军训，让我知道了什么是真正有毅力的人。</p><p>纸上得来终觉浅，觉知此事要躬行。经历了小学高中，想必我们每一位同学都知道什么是思想上的毅力，没日没夜的看书刷题，不断提升自己的做题能力，就是有思想上的毅力。但久而久之，大家似乎都仅把有思想上的毅力当成一个人有毅力的证明了，这也就是越来越多病态高精尖人才出现的一个原因吧。</p><p>殊不知，一切思想上的毅力，都应该且必然建立在身体上的毅力之上，有了身体上的毅力，思想上的毅力在每日的行动中便会被日益打磨。我们常说思想决定行动，但实际上，我们的具身认知优先级是更高的。军人就是实现身体上毅力的典型代表，每天严格的训练计划、森严的管理制度都无时无刻地影响着他们，正如徐默然学长在他的军旅生涯分享中所说：没有军营，就没有现在这个相对完整的自己。</p><p>军训，在我的思想上烙下了深刻的红色印记。</p><p>每一次的钱伟长思想文化教育都带领我们慢慢走近钱伟长老校长，领略其不凡的一生。98年，熊熊燃烧的的教育报国之火未曾熄灭，多少科研工作者能做到这般境界，这是最令我动容的一点，也正是因为这一点，让我更加坚定了自己的计算机求学之路，踏踏实实走好每一步，平心静气打好技术根基，不为荣华富贵急功近利之气改变初心。</p><p>一些优秀的动画作品也吸引了我，如《那年那兔那些事儿》，它们用一种独特的视角为我们展现了辛亥革命、南昌起义等时期的历史面貌。一个个英雄人物的出现，改变了历史的格局，开拓了中国共产党的发展道路。这些作品虽用动画呈现，但不乏真情实感，每一集的小剧场，都能发人深省、引人深思，感叹一批批先驱者们的伟大决心。</p><p>《建军大业》是党团教育中让我感触最深的一部电影。其中最令我动容的有两个画面，一个是革命英雄间的心心相惜，另一个是人民子弟兵的前仆后继。三河坝阻击战前，周恩来注视主动请缨、以千人之军阻击万人军队的朱德，眼眶湿润；阻击战末，最后一个战士，拼死拉响引爆战壕地雷的开关，轰鸣声里，是阻击战士们生命中最后的血性。</p><p>第一次能够如此投入地学习红色文化，让我对红色文化教育方法有了更深的思考，我认为党团教育策划者们可以从以下几个方面采取行动：</p><ol><li>做好实在的学生调研，了解当前同学们对党史的了解，感兴趣程度</li><li>结合调研情况调整相关课程的内容、时间，多多实验，寻找一个效果好的教学方式</li><li>学校可以专设与党史相关的社团与组织，通过社团宣传与活动让越来越多的同学参与进来，普及大家的红色文化知识</li><li>个人感觉最重要的一点：让人们真正了解到党史的价值与意义，对于每个人自身的启迪，改变当今人们对红色文化普遍的价值观。</li></ol><p>除了红色文化，学院老师们针对自己专业领域的知识分享也极大程度地拓宽了我们的知识面。从生态环境到金融世界，从全球变暖到金融学三大定律，无一不体现着多元化的奥妙。当今，正处于多元化的时代，打破学科的壁垒，是目前相当重要的任务。钱伟长老校长具有十足的前瞻性，早早地提出学科交融的重要观点，这也是上海大学立身国际化前沿的基因。</p><p> 不经风雨，怎见彩虹。</p><p>在训练的过程中，鼓励与批评相生常伴。记得在刚开始军训时，因为高温天气，我们练有很多同志感到不适请求休息，但随着时间的推移，每个人都尽力坚持下来，慢慢的，连队对技能的学习速度提升上来，也就有了我们日渐一致的步调。这就是军训带给我的最重要的一个成长。因为这种耐性，这种不灭的意志将伴随我的一生。</p><p>让我们带着军训的收获迈步向前，走向辉煌的前程！。</p>]]></content>
    
    
    <categories>
      
      <category>essay</category>
      
      <category>feel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阳光下的成长</title>
    <link href="/2021/07/22/essay/feel/%E9%98%B3%E5%85%89%E4%B8%8B%E7%9A%84%E6%88%90%E9%95%BF/"/>
    <url>/2021/07/22/essay/feel/%E9%98%B3%E5%85%89%E4%B8%8B%E7%9A%84%E6%88%90%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="不经风雨，怎见彩虹"><a href="#不经风雨，怎见彩虹" class="headerlink" title="不经风雨，怎见彩虹"></a>不经风雨，怎见彩虹<span id="more"></span></h1><div class="hljs code-wrapper"><pre><code>    我们的军训历程已行至将半，但每个人心中的坚毅之旅才刚刚启程，前方有无数风雨阻滞，然而那一道道彩虹是我们前进永远的动力之源。</code></pre></div><p>​        记得，军训带给我的第一个成长，便是认识到军训的意义与价值。军训之意义，在于纵使烈阳炙烤仍有一致步调的毅力磨练；军训之意义，在于目睹人间疾苦常于生活中无私奉献的品质养成。军训虽只有短短的两周，但影响的不仅是当下，还有将至的未来。从初中、到高中、再到大学，军训的价值，是历久弥新的，在这条路上，我越变越坚强。</p><p>​        军训所磨砺的，有我们的身体素质，还有我们的心智。从原地踏步到分裂式的手脚协调能力培养，从钱老校长事迹宣讲到无名英雄故事分享的红色精神传承。唯有作风端正，方成大气品行；唯有踏实做事，才有品格践行。文武双全，才是军训的真正目的导向。成为一个全面发展的人，是军训带给我的第二个成长。</p><p>​        不经风雨，怎见彩虹。在训练的过程中，鼓励与批评相生常伴。记得在刚开始军训时，因为高温天气，我们练有很多同志感到不适请求休息，但随着时间的推移，每个人都尽力坚持下来，慢慢的，连队对技能的学习速度提升上来，也就有了我们日渐一致的步调。这就是军训带给我的第三个，也是最重要的一个成长。因为这种耐性将伴随我的一生。</p><p>​        一个人人都具有强大集体荣誉感的联队才是一个优秀的联队；懂得先苦后甜，活在当下，才有现实主义的存在；······阳光下的成长还有许多许多。但他们都有同一个精神内核——“不经风雨，怎见彩虹”！</p>]]></content>
    
    
    <categories>
      
      <category>essay</category>
      
      <category>feel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红色教育</title>
    <link href="/2021/07/19/essay/feel/%E7%BA%A2%E8%89%B2%E6%95%99%E8%82%B2/"/>
    <url>/2021/07/19/essay/feel/%E7%BA%A2%E8%89%B2%E6%95%99%E8%82%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><span id="more"></span>晚上的红色文化教育带领我们又一次走近了钱伟长老校长，领略其不凡的一生。98年，熊熊燃烧的的教育报国之火未曾熄灭，多少科研工作者能做到这般境界，这是最令我动容的一点，也正是因为这一点，让我更加坚定了自己的计算机求学之路，踏踏实实走好每一步，平心静气打好技术根基，不为荣华富贵急功近利之气改变初心。<p>除了钱老的故事，一些优秀的动画作品也吸引了我，如《那年那兔那些事儿》，它们用一种独特的视角为我们展现了辛亥革命、南昌起义等时期的历史面貌。一个个英雄人物的出现，改变了历史的格局，开拓了中国共产党的发展道路。这些作品虽用动画呈现，但不乏真情实感，每一集的小剧场，都能发人深省、引人深思，感叹一批批先驱者们的伟大决心。</p>]]></content>
    
    
    <categories>
      
      <category>essay</category>
      
      <category>feel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/12/guide/about_hexo/hello-world/"/>
    <url>/2021/07/12/guide/about_hexo/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>guide</category>
      
      <category>about_hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
